#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(stringin, "BL45P-MO-IOC-01:DEMO")
{
    field(PINI, "YES")
    field(VAL, "Hello demo1")
}

# Used by Channel Access Security to determine access to this IOC.
record(mbbo, "BL45P-MO-IOC-01:ACCESS")
{
  field(DESC, "BL45P-MO-IOC-01 Acc Mode")
  field(PINI, "YES")
  field(ZRST, "Running")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Maintenance")
  field(ONSV, "MINOR")
  field(TWST, "Test")
  field(TWSV, "MINOR")
  field(THST, "OFFLINE")
  field(THSV, "MAJOR")
  info(autosaveFields, "VAL")
}
record(stringin, "BL45P-MO-IOC-01:STARTTOD")
{
    field(DESC, "Time and date of startup")
    field(DTYP, "Soft Timestamp")
    field(PINI, "YES")
    field(INP, "@%Y-%m-%d %H:%M:%S")
}
record(stringin, "BL45P-MO-IOC-01:TOD")
{
    field(DESC, "Current time and date")
    field(DTYP, "Soft Timestamp")
    field(SCAN, "1 second")
    field(INP, "@%Y-%m-%d %H:%M:%S")
}
record(calcout, "BL45P-MO-IOC-01:HEARTBEAT")
{
    field(DESC, "1 Hz counter since startup")
    field(CALC, "(A<2147483647)?A+1:1")
    field(SCAN, "1 second")
    field(INPA, "BL45P-MO-IOC-01:HEARTBEAT")
}
# if autosave is working, START_CNT creates a running count of
# number of times the IOC was started.
record(calcout, "BL45P-MO-IOC-01:START_CNT")
{
    field(DESC, "Increments at startup")
    field(CALC, "A+1")
    field(PINI, "YES")
    field(INPA, "BL45P-MO-IOC-01:START_CNT")
    info(autosaveFields_pass0, "VAL")
}
#
# Using an existing internal set of subroutines, this
# PV updates the Access Security mechanism dynamically.
# The .acf file is re-read.
#
record( sub, "BL45P-MO-IOC-01:READACF")
{
    field( DESC, "BL45P-MO-IOC-01 ACF Update")
    field( INAM, "asSubInit")
    field( SNAM, "asSubProcess")
    field( BRSV, "INVALID")
}
record(sub, "BL45P-MO-IOC-01:SYSRESET")
{
    alias("BL45P-MO-IOC-01:SysReset")
    field(DESC, "IOC Restart" )
    field(SNAM, "rebootProc")
    field(BRSV,"INVALID")
    field(L,"1")
}

#% archiver 1 Monitor
#% alh
record(ai, "BL45P-MO-IOC-01:CA_CLNT_CNT") {
  field(DESC, "Number of CA Clients")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@ca_clients")
  field(HOPR, "200")
  field(HIHI, "175")
  field(HIGH, "100")
  field(HHSV, "MAJOR")
  field(HSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR HIHI HIGH LOW LOLO HHSV HSV LSV LLSV")
}

#% archiver 1 Monitor
#% alh
record(ai, "BL45P-MO-IOC-01:CA_CONN_CNT") {
  field(DESC, "Number of CA Connections")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@ca_connections")
  field(HOPR, "5000")
  field(HIHI, "4500")
  field(HIGH, "4000")
  field(HHSV, "MAJOR")
  field(HSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR HIHI HIGH LOW LOLO HHSV HSV LSV LLSV")
}

record(ai, "BL45P-MO-IOC-01:RECORD_CNT") {
  field(DESC, "Number of Records")
  field(PINI, "YES")
  field(DTYP, "IOC stats")
  field(INP, "@records")
}

record(ai, "BL45P-MO-IOC-01:FD_MAX") {
  field(DESC, "Max File Descriptors")
  field(PINI, "YES")
  field(DTYP, "IOC stats")
  field(INP, "@maxfd")
}

record(ai, "BL45P-MO-IOC-01:FD_CNT") {
  field(DESC, "Allocated File Descriptors")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(FLNK, "BL45P-MO-IOC-01:FD_FREE  PP MS")
  field(INP, "@fd")
}

#% archiver 1 Monitor
#% alh
record(calc, "BL45P-MO-IOC-01:FD_FREE") {
  field(DESC, "Available FDs")
  field(CALC, "B>0?B-A:C")
  field(INPA, "BL45P-MO-IOC-01:FD_CNT  NPP MS")
  field(INPB, "BL45P-MO-IOC-01:FD_MAX  NPP MS")
  field(INPC, "1000")
  field(HOPR, "150")
  field(LOLO, "5")
  field(LOW, "20")
  field(LLSV, "MAJOR")
  field(LSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR LOW LOLO LSV LLSV")
}

#% archiver 1 Monitor
record(ai, "BL45P-MO-IOC-01:SYS_CPU_LOAD") {
  field(DESC, "System CPU Load")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@sys_cpuload")
  field(EGU, "%")
  field(PREC, "1")
  field(HOPR, "100")
  field(HIHI, "80")
  field(HIGH, "70")
  field(HHSV, "MAJOR")
  field(HSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR HIHI HIGH LOW LOLO HHSV HSV LSV LLSV")
}

#% archiver 1 Monitor
#% alh
record(ai, "BL45P-MO-IOC-01:IOC_CPU_LOAD") {
  alias("BL45P-MO-IOC-01:LOAD")
  field(DESC, "IOC CPU Load")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@ioc_cpuload")
  field(EGU, "%")
  field(PREC, "1")
  field(HOPR, "100")
  field(HIHI, "80")
  field(HIGH, "70")
  field(HHSV, "MAJOR")
  field(HSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR HIHI HIGH LOW LOLO HHSV HSV LSV LLSV")
}

record(ai, "BL45P-MO-IOC-01:CPU_CNT") {
  field(DESC, "Number of CPUs")
  field(DTYP, "IOC stats")
  field(INP, "@no_of_cpus")
  field(PINI, "YES")
}

#% archiver 1 Monitor
#% alh
record(ai, "BL45P-MO-IOC-01:SUSP_TASK_CNT") {
  field(DESC, "Number Suspended Tasks")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@suspended_tasks")
  field(HIHI, "1")
  field(HHSV, "MAJOR")
  info(autosaveFields_pass0, "HOPR LOPR HIHI HIGH LOW LOLO HHSV HSV LSV LLSV")
}

#% archiver 1 Monitor
record(ai, "BL45P-MO-IOC-01:MEM_USED") {
  field(DESC, "Allocated Memory")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@allocated_bytes")
  field(EGU, "byte")
}

#% archiver 1 Monitor
record(ai, "BL45P-MO-IOC-01:MEM_FREE") {
  field(DESC, "Free Memory")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@free_bytes")
  field(EGU, "byte")
  field(LLSV, "MAJOR")
  field(LSV, "MINOR")
  info(autosaveFields_pass0, "HOPR LOPR LOW LOLO LSV LLSV")
}

record(ai, "BL45P-MO-IOC-01:MEM_MAX") {
  field(DESC, "Maximum Memory")
  field(SCAN, "I/O Intr")
  field(DTYP, "IOC stats")
  field(INP, "@total_bytes")
  field(EGU, "byte")
}

record(ao, "BL45P-MO-IOC-01:CA_UPD_TIME") {
  field(DESC, "CA Check Update Period")
  field(DTYP, "IOC stats")
  field(OUT, "@ca_scan_rate")
  field(EGU, "sec")
  field(DRVH, "60")
  field(DRVL, "1")
  field(HOPR, "60")
  field(VAL, "15")
  field(PINI, "YES")
}

record(ao, "BL45P-MO-IOC-01:FD_UPD_TIME") {
  field(DESC, "FD Check Update Period")
  field(DTYP, "IOC stats")
  field(OUT, "@fd_scan_rate")
  field(EGU, "sec")
  field(DRVH, "60")
  field(DRVL, "1")
  field(HOPR, "60")
  field(VAL, "20")
  field(PINI, "YES")
}

record(ao, "BL45P-MO-IOC-01:LOAD_UPD_TIME") {
  field(DESC, "CPU Check Update Period")
  field(DTYP, "IOC stats")
  field(OUT, "@cpu_scan_rate")
  field(EGU, "sec")
  field(DRVH, "60")
  field(DRVL, "1")
  field(HOPR, "60")
  field(VAL, "10")
  field(PINI, "YES")
}

record(ao, "BL45P-MO-IOC-01:MEM_UPD_TIME") {
  field(DESC, "Memory Check Update Period")
  field(DTYP, "IOC stats")
  field(OUT, "@memory_scan_rate")
  field(EGU, "sec")
  field(DRVH, "60")
  field(DRVL, "1")
  field(HOPR, "60")
  field(VAL, "10")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:ST_SCRIPT1") {
  field(DESC, "Startup Script Part1")
  field(DTYP, "IOC stats")
  field(INP, "@startup_script_1")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:ST_SCRIPT2") {
  field(DESC, "Startup Script Part2")
  field(DTYP, "IOC stats")
  field(INP, "@startup_script_2")
  field(PINI, "YES")
}

record(waveform, "BL45P-MO-IOC-01:ST_SCRIPT") {
  field(DESC, "Startup Script")
  field(DTYP, "IOC stats")
  field(INP, "@startup_script")
  field(NELM, "120")
  field(FTVL, "CHAR")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:KERNEL_VERS") {
  field(DESC, "Kernel Version")
  field(DTYP, "IOC stats")
  field(INP, "@kernel_ver")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:EPICS_VERS") {
  field(DESC, "EPICS Version")
  field(DTYP, "IOC stats")
  field(INP, "@epics_ver")
  field(PINI, "YES")
}

record(waveform, "BL45P-MO-IOC-01:EPICS_VERSION") {
  field(DESC, "EPICS Version")
  field(DTYP, "IOC stats")
  field(INP, "@epics_ver")
  field(NELM, "120")
  field(FTVL, "CHAR")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:HOSTNAME") {
  field(DESC, "Host Name")
  field(DTYP, "IOC stats")
  field(INP, "@hostname")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:APP_DIR1") {
  field(DESC, "Application Directory Part 1")
  field(DTYP, "IOC stats")
  field(INP, "@pwd1")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:APP_DIR2") {
  field(DESC, "Application Directory Part 2")
  field(DTYP, "IOC stats")
  field(INP, "@pwd2")
  field(PINI, "YES")
}

record(waveform, "BL45P-MO-IOC-01:APP_DIR") {
  field(DESC, "Application Directory")
  field(DTYP, "IOC stats")
  field(INP, "@pwd")
  field(NELM, "160")
  field(FTVL, "CHAR")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:UPTIME") {
  field(DESC, "Elapsed Time since Start")
  field(SCAN, "1 second")
  field(DTYP, "IOC stats")
  field(INP, "@up_time")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:ENGINEER") {
  field(DESC, "Engineer")
  field(DTYP, "IOC stats")
  field(INP, "@engineer")
  field(PINI, "YES")
}

record(stringin, "BL45P-MO-IOC-01:LOCATION") {
  field(DESC, "Location")
  field(DTYP, "IOC stats")
  field(INP, "@location")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-IOC-01:PROCESS_ID") {
  field(DESC, "Process ID")
  field(PINI, "YES")
  field(DTYP, "IOC stats")
  field(INP, "@proc_id")
}

record(ai, "BL45P-MO-IOC-01:PARENT_ID") {
  field(DESC, "Parent Process ID")
  field(PINI, "YES")
  field(DTYP, "IOC stats")
  field(INP, "@parent_proc_id")
}

record(stringin, "BL45P-MO-IOC-01:DLSVER") {
  field(DESC, "IOC version")
  field(DTYP, "IOC stats")
  field(INP, "@dlsver")
  field(PINI, "YES")
}
record(ai, "BL45P-MO-IOC-01:GTIM_TIME") {
  field(DESC, "Gen Time Secs since 1990")
  field(SCAN, "1 second")
  field(DTYP, "General Time")
  field(PREC, "3")
  field(INP,  "@TIME")
  field(EGU,  "sec")
}

record(bo, "BL45P-MO-IOC-01:GTIM_RESET") {
  field(DESC, "Gen Time Error Reset")
  field(DTYP, "General Time")
  field(OUT,  "@RSTERRCNT")
  field(ZNAM, "Reset")
  field(ONAM, "Reset")
}

record(longin, "BL45P-MO-IOC-01:GTIM_ERR_CNT") {
  field(DESC, "Gen Time Error Count")
  field(DTYP, "General Time")
  field(INP,  "@GETERRCNT")
  field(SCAN, "1 second")
  field(HIHI, "1")
  field(HHSV, "MAJOR")
}

record(stringin, "BL45P-MO-IOC-01:GTIM_CUR_SRC") {
  field(DESC, "Gen Time Current Provider")
  field(DTYP, "General Time")
  field(INP,  "@BESTTCP")
  field(SCAN, "1 second")
}

record(stringin, "BL45P-MO-IOC-01:GTIM_EVT_SRC") {
  field(DESC, "Gen Time Event Provider")
  field(DTYP, "General Time")
  field(INP,  "@BESTTEP")
  field(SCAN, "1 second")
}

record(stringin, "BL45P-MO-IOC-01:GTIM_HI_SRC") {
  field(DESC, "Gen Time Highest Provider")
  field(DTYP, "General Time")
  field(INP,  "@TOPTCP")
  field(SCAN, "1 second")
}
record(stringin, "BL45P-MO-IOC-01:CA_ADDR_LIST") {
  field(DESC, "EPICS_CA_ADDR_LIST")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_ADDR_LIST")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_CONN_TIME") {
  field(DESC, "EPICS_CA_CONN_TMO")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_CONN_TMO")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_AUTO_ADDR") {
  field(DESC, "EPICS_CA_AUTO_ADDR_LIST")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_AUTO_ADDR_LIST")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_RPTR_PORT") {
  field(DESC, "EPICS_CA_REPEATER_PORT")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_REPEATER_PORT")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_SRVR_PORT") {
  field(DESC, "EPICS_CA_SERVER_PORT")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_SERVER_PORT")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_MAX_ARRAY") {
  field(DESC, "EPICS_CA_MAX_ARRAY_BYTES")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_MAX_ARRAY_BYTES")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_SRCH_TIME") {
  field(DESC, "EPICS_CA_MAX_SEARCH_PERIOD")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_MAX_SEARCH_PERIOD")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:CA_BEAC_TIME") {
  field(DESC, "EPICS_CA_BEACON_PERIOD")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_CA_BEACON_PERIOD")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:TIMEZONE") {
  field(DESC, "EPICS_TIMEZONE")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_TIMEZONE")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:TS_NTP_INET") {
  field(DESC, "EPICS_TS_NTP_INET")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_TS_NTP_INET")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:IOC_LOG_PORT") {
  field(DESC, "EPICS_IOC_LOG_PORT")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_IOC_LOG_PORT")
  field(PINI, "YES")
}
record(stringin, "BL45P-MO-IOC-01:IOC_LOG_INET") {
  field(DESC, "EPICS_IOC_LOG_INET")
  field(DTYP, "IOC epics var")
  field(INP, "@EPICS_IOC_LOG_INET")
  field(PINI, "YES")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:01HZ_MODE") {
	field(DESC, "01HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:01HZ_UPD_TIME") {
	field(DESC, "01HZ Update Time")
	field(SCAN, "10 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:01HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:02HZ_MODE") {
	field(DESC, "02HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:02HZ_UPD_TIME") {
	field(DESC, "02HZ Update Time")
	field(SCAN, "5 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:02HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:05HZ_MODE") {
	field(DESC, "05HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:05HZ_UPD_TIME") {
	field(DESC, "05HZ Update Time")
	field(SCAN, "2 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:05HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:1HZ_MODE") {
	field(DESC, "1HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:1HZ_UPD_TIME") {
	field(DESC, "1HZ Update Time")
	field(SCAN, "1 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:1HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:2HZ_MODE") {
	field(DESC, "2HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:2HZ_UPD_TIME") {
	field(DESC, "2HZ Update Time")
	field(SCAN, ".5 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:2HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:5HZ_MODE") {
	field(DESC, "5HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:5HZ_UPD_TIME") {
	field(DESC, "5HZ Update Time")
	field(SCAN, ".2 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:5HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}
#% macro, __doc__, Create some records for reading IOC statistics and details.
#% macro, IOC, Device prefix

record(bo, "BL45P-MO-IOC-01:10HZ_MODE") {
	field(DESC, "10HZ Mode")
	field(DOL, "1")
	field(PINI, "YES")
	field(ZNAM, "Relative")
	field(ONAM, "Absolute")
}
record(sub, "BL45P-MO-IOC-01:10HZ_UPD_TIME") {
	field(DESC, "10HZ Update Time")
	field(SCAN, ".1 second")
	field(EGU, "second")
	field(PREC, "5")
	field(MDEL, "0.00001")
	field(HYST, "0.00002")
	field(INAM, "scanMonInit")
	field(SNAM, "scanMon")
	field(HHSV, "MAJOR")
	field(HSV, "MINOR")
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(BRSV, "INVALID")
	field(INPA, "BL45P-MO-IOC-01:10HZ_MODE")
	field(B,    "1.0")
	field(C,    "5.0")
}

record(calc, "BL45P-MO-IOC-01:SCANMON_SEVR") {
    field(DESC, "ScanMon Max Severity")
    field(SCAN, "1 second")
    field(CALC, "0")
    field(INPA, "BL45P-MO-IOC-01:01HZ_UPD_TIME.SEVR MS")
    field(INPB, "BL45P-MO-IOC-01:02HZ_UPD_TIME.SEVR MS")
    field(INPC, "BL45P-MO-IOC-01:05HZ_UPD_TIME.SEVR MS")
    field(INPD, "BL45P-MO-IOC-01:1HZ_UPD_TIME.SEVR MS")
    field(INPE, "BL45P-MO-IOC-01:2HZ_UPD_TIME.SEVR MS")
    field(INPF, "BL45P-MO-IOC-01:5HZ_UPD_TIME.SEVR MS")
    field(INPG, "BL45P-MO-IOC-01:10HZ_UPD_TIME.SEVR MS")
}

# % macro, name, name for gui elements
# % macro, EDM_FILE, edm screen, defaults to ioc_stats_softdls.edl
# % macro, IOC, ioc name

# % gui, MO1_STATS, edm, ioc_stats_softdls.edl, ioc=BL45P-MO-IOC-01
# % gui, MO1_STATS, edmembed, ioc_embed.edl, ioc=BL45P-MO-IOC-01,EDM_FILE=ioc_stats_softdls.edl



# This associates BOY screens with the template
# % gui, MO1_STATS, boydetail, devIocStatsApp_opi/iocStats_detail.opi, desc=BL45P-MO-IOC-01, IOC=BL45P-MO-IOC-01, name=MO1_STATS
# % gui, MO1_STATS, boyembed, devIocStatsApp_opi/iocStats_embed.opi, desc=BL45P-MO-IOC-01,  IOC=BL45P-MO-IOC-01, name=MO1_STATS
# % gui, MO1_STATS, boyembed, devIocStatsApp_opi/iocStats_embed_box.opi, desc=BL45P-MO-IOC-01,  IOC=BL45P-MO-IOC-01, name=MO1_STATS

# These define what PVs a detail screen should contain
# % gui, MO1_STATS, readback, Startup Time,BL45P-MO-IOC-01:STARTOD
# % gui, MO1_STATS, readback, Current Time,BL45P-MO-IOC-01:TOD
# % gui, MO1_STATS, readback, Up Time,BL45P-MO-IOC-01:UPTIME
# % gui, MO1_STATS, readback, Heartbeat,BL45P-MO-IOC-01:HEARTBEAT
# % gui, MO1_STATS, readback, Records,BL45P-MO-IOC-01:RECORD_CNT
# % gui, MO1_STATS, readback, Host Name,BL45P-MO-IOC-01:HOSTNAME
# % gui, MO1_STATS, readback, User Name,BL45P-MO-IOC-01:ENGINEER
# % gui, MO1_STATS, readback, Location,BL45P-MO-IOC-01:LOCATION
# % gui, MO1_STATS, readback, CA Clients,BL45P-MO-IOC-01:CA_CLNT_CNT
# % gui, MO1_STATS, readback, CA PV Conns,BL45P-MO-IOC-01:CA_CONN_CNT
# % gui, MO1_STATS, readback, Susp Tasks,BL45P-MO-IOC-01:SUSP_TASK_CNT
# % gui, MO1_STATS, readback, EPICS Version,BL45P-MO-IOC-01:EPICS_VERS
# % gui, MO1_STATS, readback, OS Version,BL45P-MO-IOC-01:KERNEL_VERS
# % gui, MO1_STATS, readback, Application Directory,BL45P-MO-IOC-01:APP_DIR1
# % gui, MO1_STATS, readback, Startup Script,BL45P-MO-IOC-01:ST_SCRIPT1
# % gui, MO1_STATS, readback, Memory Free,BL45P-MO-IOC-01:MEM_FREE
# % gui, MO1_STATS, readback, Memory Used,BL45P-MO-IOC-01:MEM_USED
# % gui, MO1_STATS, readback, Memory Max,BL45P-MO-IOC-01:MEM_MAX
# % gui, MO1_STATS, readback, File Handles Free,BL45P-MO-IOC-01:FD_FREE
# % gui, MO1_STATS, readback, File Handles Max,BL45P-MO-IOC-01:FD_MAX
# % gui, MO1_STATS, readback, IOC CPU Load,BL45P-MO-IOC-01:IOC_CPU_LOAD
# % gui, MO1_STATS, readback, All CPUs Load,BL45P-MO-IOC-01:SYS_CPU_LOAD
# % gui, MO1_STATS, readback, System CPUs,BL45P-MO-IOC-01:CPU_CNT

##############################################################
#
# Records to read asynPortDriver parameters from the param
# library for the class pmacController.
#
# The Asyn address is set as zero because that's what we use
# for controller parameters.
#
##############################################################

# % macro, PORT, The asyn port for the pmac controller
# % macro, P, PV Prefix
# % macro, NAXES, Number of axes
# % macro, TIMEOUT, Timeout for controller communication
# % macro, FEEDRATE, feedrate below which we go into error
# % macro, CSG0, Name for Coordinate System Group 0
# % macro, CSG1, Name for Coordinate System Group 1
# % macro, CSG2, Name for Coordinate System Group 2
# % macro, CSG3, Name for Coordinate System Group 3
# % macro, CSG4, Name for Coordinate System Group 4
# % macro, CSG5, Name for Coordinate System Group 5
# % macro, CSG6, Name for Coordinate System Group 6
# % macro, CSG7, Name for Coordinate System Group 7

#
# This associates an edm screen with the template
# % gui, BRICK1, edm, pmacController.edl, pmac=BL45P-MO-STEP-01
#

#
# allow query of this controller's Port Name
#
record(stringout, "BL45P-MO-STEP-01:Port")
{
    field(VAL, "BRICK1")
    field(PINI, "YES")
}

##############################################################
# Listing of combined Slow Poll Variables
##############################################################
record(waveform, "BL45P-MO-STEP-01:I_VARIABLES_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PMAC_I_VARIABLES")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:P_VARIABLES_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PMAC_P_VARIABLES")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:M_VARIABLES_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PMAC_M_VARIABLES")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

##############################################################
# Ensure all PVs are up to date with the current brick state
##############################################################
record(busy,"BL45P-MO-STEP-01:PollAllNow") {
    field(DESC,"Poll brick status")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PMAC_C_POLLALLNOW")
    field(ZNAM, "Done")
    field(ONAM, "Polling")
}

##############################################################
# Control deferred mode for all real 1axes in this brick
##############################################################
record(bo, "BL45P-MO-STEP-01:DeferMoves")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0,4)MOTOR_DEFER_MOVES")
    field(VAL, "0")
    field(ZNAM, "Defer Off")
    field(ONAM, "Defer On")
}

##############################################################
# Send stop all command
##############################################################
record(bo, "BL45P-MO-STEP-01:StopAll")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_STOPALL")
}

##############################################################
# Control deferred mode for all real 1axes in this brick
##############################################################
record(bo, "BL45P-MO-STEP-01:KillAll")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_KILLALL")
}

##############################################################
# Send arbitrary command to the geobrick controller
##############################################################
record(waveform, "BL45P-MO-STEP-01:SendCmd")
{
    field(DTYP, "asynOctetWrite")
    field(FTVL, "CHAR")
    field(INP,  "@asyn(BRICK1,0,4)PMAC_C_WRITE_CMD")
    field(NELM, "100")
    field(SCAN, "Passive")
}


# a dummy real motor 0 with mres of 1, used by the CS axis mres DB logic in pmacDirectMotor.template
record(motor,"BL45P-MO-STEP-01:M0")
{
	field(DTYP,"Soft Channel")
	field(MRES,"1")
}

# ///
# /// Select a group of coordinate systems into the controller.
# ///
# % autosave 2
record(mbbo, "BL45P-MO-STEP-01:COORDINATE_SYS_GROUP")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_COORDINATE_SYS_GROUP")
   field(VAL, "0")
   field(ZRST, "CS1-direct")
   field(ZRVL, "0")
   field(ONST, "CS2-kinematic")
   field(ONVL, "1")
   field(TWST, "")
   field(TWVL, "2")
   field(THST, "")
   field(THVL, "3")
   field(FRST, "")
   field(FRVL, "4")
   field(FVST, "")
   field(FVVL, "5")
   field(SXST, "")
   field(SXVL, "6")
   field(SVST, "")
   field(SVVL, "7")
}

# ///
# /// Read back the current group of coordinate systems into the controller.
# ///
record(mbbi, "BL45P-MO-STEP-01:COORDINATE_SYS_GROUP_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(BRICK1,0,4)PMAC_C_COORDINATE_SYS_GROUP")
   field(SCAN, "I/O Intr")
   field(ZRST, "CS1-direct")
   field(ZRVL, "0")
   field(ONST, "CS2-kinematic")
   field(ONVL, "1")
   field(TWST, "")
   field(TWVL, "2")
   field(THST, "")
   field(THVL, "3")
   field(FRST, "")
   field(FRVL, "4")
   field(FVST, "")
   field(FVVL, "5")
   field(SXST, "")
   field(SXVL, "6")
   field(SVST, "")
   field(SVVL, "7")
}

#
# Control read only mode for axes
#
record(bo, "BL45P-MO-STEP-01:AxesReadonly")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_AXIS_READONLY")
    field(VAL, "0")
    field(ZNAM, "Read/Write")
    field(ONAM, "Readonly")
}

#
# Read back the readonly mode for axes
#
record(bi, "BL45P-MO-STEP-01:AxesReadonly_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(BRICK1,0,4)PMAC_C_AXIS_READONLY")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Read/Write")
    field(ONAM, "Readonly")
}

#####################################################
# Below are the records originally from
#    pmacStatus.template
#####################################################

# pmac type record
record(mbbi, "BL45P-MO-STEP-01:PMACTYPE") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(ZRVL, "604020")
  field(ONVL, "602413")
  field(TWVL, "603382")
  field(THVL, "602404")
  field(ZRST, "Power PMAC")
  field(ONST, "Turbo PMAC2")
  field(TWST, "Geobrick LV")
  field(THST, "PMAC Clipper")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VIM_cid")
}

# % archiver 10 Monitor
# This makes the component icon reflect the severity
# % gui, BRICK1, sevr
record(ai, "BL45P-MO-STEP-01:CPULOAD") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_CPU_USAGE")
  field(PREC, "2")
  field(EGU, "%")
  field(HIGH, "60")
  field(HSV, "MINOR")
  field(HIHI, "80")
  field(HHSV, "MAJOR")
}

record(ai, "BL45P-MO-STEP-01:SERVO_FREQ") {
  field(EGU, "Hz")
  field(PREC, "1")
}

record(longin, "BL45P-MO-STEP-01:READ_CTRLSTAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_STATUS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:CTRLSTAT:status1")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:CTRLSTAT:status1") {
  field(INP, "BL45P-MO-STEP-01:READ_CTRLSTAT1")
}

record(longin, "BL45P-MO-STEP-01:READ_CTRLSTAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_STATUS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:CTRLSTAT:status2")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:CTRLSTAT:status2") {
  field(INP, "BL45P-MO-STEP-01:READ_CTRLSTAT2")
}

record(longin, "BL45P-MO-STEP-01:READ_CTRLSTAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_STATUS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:CTRLSTAT:status3")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:CTRLSTAT:status3") {
  field(INP, "BL45P-MO-STEP-01:READ_CTRLSTAT3")
}


record(longin, "BL45P-MO-STEP-01:READ_PLCBITS00") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_PLC_BITS00")
  field(FLNK, "BL45P-MO-STEP-01:PLCDISBITS00")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:PLCDISBITS00") {
  field(INP, "BL45P-MO-STEP-01:READ_PLCBITS00")
}

record(longin, "BL45P-MO-STEP-01:READ_PLCBITS01") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_PLC_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:PLCDISBITS01")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:PLCDISBITS01") {
  field(INP, "BL45P-MO-STEP-01:READ_PLCBITS01")
}

record(longin, "BL45P-MO-STEP-01:READ_GPIO_INP") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_GPIO_INPUTS")
  field(FLNK, "BL45P-MO-STEP-01:GPIO_INP_BITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:GPIO_INP_BITS") {
  field(INP, "BL45P-MO-STEP-01:READ_GPIO_INP")
}

record(longin, "BL45P-MO-STEP-01:READ_GPIO_OUT") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_GPIO_OUTPUTS")
  field(FLNK, "BL45P-MO-STEP-01:GPIO_OP_BITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:GPIO_OP_BITS") {
  field(INP, "BL45P-MO-STEP-01:READ_GPIO_OUT")
}

record(longin, "BL45P-MO-STEP-01:READ_PROGBITS") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_C_PROG_BITS")
  field(FLNK, "BL45P-MO-STEP-01:PROGBITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:PROGBITS") {
  field(INP, "BL45P-MO-STEP-01:READ_PROGBITS")
}

record(ai, "BL45P-MO-STEP-01:MACROERRS") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDM_M5035")
}

record(seq, "BL45P-MO-STEP-01:AXIS1:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS2:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS3:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS4:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS5:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS6:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS7:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS8:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS9:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS10:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS11:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS12:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS13:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS14:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS15:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS16:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS17:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS18:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS19:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS20:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS21:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS22:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS23:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS24:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS25:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS26:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS27:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS28:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS29:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS30:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS31:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AXIS32:ReadBack") {
}

record(seq, "BL45P-MO-STEP-01:AxisRB") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS1:ReadBack.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS2:ReadBack.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS3:ReadBack.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS4:ReadBack.PROC PP")
  field(LNK5, "BL45P-MO-STEP-01:AXIS5:ReadBack.PROC PP")
  field(LNK6, "BL45P-MO-STEP-01:AXIS6:ReadBack.PROC PP")
  field(LNK7, "BL45P-MO-STEP-01:AXIS7:ReadBack.PROC PP")
  field(LNK8, "BL45P-MO-STEP-01:AXIS8:ReadBack.PROC PP")
  field(LNK9, "BL45P-MO-STEP-01:AxisRB2.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BL45P-MO-STEP-01:AxisRB2") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS9:ReadBack.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS10:ReadBack.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS11:ReadBack.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS12:ReadBack.PROC PP")
  field(LNK5, "BL45P-MO-STEP-01:AXIS13:ReadBack.PROC PP")
  field(LNK6, "BL45P-MO-STEP-01:AXIS14:ReadBack.PROC PP")
  field(LNK7, "BL45P-MO-STEP-01:AXIS15:ReadBack.PROC PP")
  field(LNK8, "BL45P-MO-STEP-01:AXIS16:ReadBack.PROC PP")
  field(LNK9, "BL45P-MO-STEP-01:AxisRB3.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BL45P-MO-STEP-01:AxisRB3") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS17:ReadBack.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS18:ReadBack.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS19:ReadBack.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS20:ReadBack.PROC PP")
  field(LNK5, "BL45P-MO-STEP-01:AXIS21:ReadBack.PROC PP")
  field(LNK6, "BL45P-MO-STEP-01:AXIS22:ReadBack.PROC PP")
  field(LNK7, "BL45P-MO-STEP-01:AXIS23:ReadBack.PROC PP")
  field(LNK8, "BL45P-MO-STEP-01:AXIS24:ReadBack.PROC PP")
  field(LNK9, "BL45P-MO-STEP-01:AxisRB4.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BL45P-MO-STEP-01:AxisRB4") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS25:ReadBack.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS26:ReadBack.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS27:ReadBack.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS28:ReadBack.PROC PP")
  field(LNK5, "BL45P-MO-STEP-01:AXIS29:ReadBack.PROC PP")
  field(LNK6, "BL45P-MO-STEP-01:AXIS30:ReadBack.PROC PP")
  field(LNK7, "BL45P-MO-STEP-01:AXIS31:ReadBack.PROC PP")
  field(LNK8, "BL45P-MO-STEP-01:AXIS32:ReadBack.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
}

record(longin, "BL45P-MO-STEP-01:NAXES") {
  field(PINI, "YES")
  field(VAL, "8")
}

##############################################################
# This record indicates if we have a controller problem
##############################################################

# ///
# /// Record used to indicate if the controller has a problem. This is set in the
# /// controller poll loop, and is used to set the motor record axis status.
# ///
record(bi, "BL45P-MO-STEP-01:GLOBAL_PROBLEM_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(BRICK1,0,4)PMAC_C_GLOBALSTATUS")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Status OK")
   field(ONAM, "Status Problem")
}

##############################################################
# Monitor and set the PMAC feedrate
##############################################################

# ///
# /// Get the PMAC feedrate. This is read in the controller poll loop.
# ///
record(ai, "BL45P-MO-STEP-01:FEEDRATE_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(BRICK1,0,4)PMAC_C_FEEDRATE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")
}

# ///
# /// Set the PMAC feedrate limit. This determins if the current feedrate
# /// read from the controller is out of range, and will be used to set axis alarms.
# ///
record(longout, "BL45P-MO-STEP-01:FEEDRATE_LIMIT")
{
   field(PINI, "YES")
   field(VAL, "100")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_FEEDRATE_LIMIT")
   field(DRVH, "100")
   field(DRVL, "0")
}

# ///
# /// Set the PMAC feedrate limit. This writes a new feedrate to
# /// the controller.
# ///
record(longout, "BL45P-MO-STEP-01:FEEDRATE")
{
   field(PINI, "YES")
   field(VAL, "100")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(BRICK1,0,4)PMAC_C_FEEDRATE")
   field(DRVH, "100")
   field(DRVL, "0")
}

# ///
# /// Record used to indicate if the feedrate is below the limit. This is set from the
# /// controller poll loop, and is used to set the motor record axis status.
# ///
record(bi, "BL45P-MO-STEP-01:FEEDRATE_PROBLEM_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(BRICK1,0,4)PMAC_C_FEEDRATE_PROBLEM")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Feedrate OK")
   field(ONAM, "Feedrate Problem")
}

###################################################################
#  These records report the current comms statistics              #
#                                                                 #
###################################################################

record(longin, "BL45P-MO-STEP-01:STAT_MSG_NO_RBV") {
  field(DESC, "Number of messages sent")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_NO_OF_MSGS")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_TOTAL_WRITE_RBV") {
  field(DESC, "Total bytes written")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TBYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_TOTAL_READ_RBV") {
  field(DESC, "Total bytes read")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TBYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MSG_WRITE_RBV") {
  field(DESC, "Last message bytes written")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MBYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MSG_READ_RBV") {
  field(DESC, "Last message bytes read")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MBYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MSG_TIME_RBV") {
  field(DESC, "Last message time (ms)")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MSG_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MAX_WRITE_RBV") {
  field(DESC, "Maximum written bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MAX_BYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MAX_READ_RBV") {
  field(DESC, "Maximum read bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MAX_BYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_MAX_TIME_RBV") {
  field(DESC, "Maximum time for message")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MAX_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_AVE_WRITE_RBV") {
  field(DESC, "Average written bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_AVE_BYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_AVE_READ_RBV") {
  field(DESC, "Average read bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_AVE_BYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:STAT_AVE_TIME_RBV") {
  field(DESC, "Average time for message")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_AVE_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:FAST_SIZE_RBV") {
  field(DESC, "Size of fast PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_FAST_STORE")
  field(SCAN, "I/O Intr")
}

record(longout, "BL45P-MO-STEP-01:REPORT_FAST") {
  field(DESC, "Report the contents of fast store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_REPORT_FAST")
}

record(longin, "BL45P-MO-STEP-01:MEDIUM_SIZE_RBV") {
  field(DESC, "Size of medium PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_MEDIUM_STORE")
  field(SCAN, "I/O Intr")
}

###################################################################
#  These records support debugging                                #
#                                                                 #
###################################################################

record(longout, "BL45P-MO-STEP-01:REPORT_MEDIUM") {
  field(DESC, "Report the contents of medium store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_REPORT_MEDIUM")
}

record(longin, "BL45P-MO-STEP-01:SLOW_SIZE_RBV") {
  field(DESC, "Size of slow PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_SLOW_STORE")
  field(SCAN, "I/O Intr")
}

record(longout, "BL45P-MO-STEP-01:REPORT_SLOW") {
  field(DESC, "Report the contents of slow store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_REPORT_SLOW")
}

record(longout, "BL45P-MO-STEP-01:DEBUG_LEVEL"){
  field(DESC, "Set the debug level")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_DEBUG_LEVEL")
}

record(longout, "BL45P-MO-STEP-01:DEBUG_AXISNO"){
  field(DESC, "Debug which axis (0 is controller)")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_DEBUG_AXIS")
}

record(longout, "BL45P-MO-STEP-01:DEBUG_CSNO"){
  field(DESC, "Debug which CS (0 is main controller)")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_DEBUG_CS")
}

record(longout, "BL45P-MO-STEP-01:DEBUG_EXECUTE"){
  field(DESC, "Apply the debug settings")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_DEBUG_CMD")
}

record(mbbo, "BL45P-MO-STEP-01:DISABLE_POLL")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(BRICK1,0)PMAC_C_DEBUG_POLL_OFF")
   field(VAL, "0")
   field(ZRST, "Enabled")
   field(ZRVL, "0")
   field(ONST, "Disabled")
   field(ONVL, "1")
}# pmacStatus.template - device specific status PVs not compatible with
# power PMAC
# % macro, PORT, The asyn port for the pmac controller
# % macro, P, PV Prefix


record(longin, "BL45P-MO-STEP-01:I10") {
  field(DESC, "Servo Interrupt Time")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I10")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:CALC_SERVO_FREQ") {
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(CALC, "8388608000.0/A")
  field(INPA, "BL45P-MO-STEP-01:I10 CP")
  field(OOPT, "On Change")
  field(DOPT, "Use CALC")
  field(OUT, "BL45P-MO-STEP-01:SERVO_FREQ PP")
}

# I3 value 0 to 3 I/O Handshake control
record(mbbi, "BL45P-MO-STEP-01:IO_HANDSHAKE") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(ZRST, "No Ack (0)")
  field(ONST, "Dumb term (1)")
  field(TWST, "Fast comms (2)")
  field(THST, "Fastcomms+LF(3)")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I3")
  field(SCAN, "I/O Intr")
}

# I5 PLC Program Control
record(mbbi, "BL45P-MO-STEP-01:PLC_CONTROL") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I5")
  field(ZRVL, "0")
  field(ZRST, "NONE (0)")
  field(ONVL, "1")
  field(ONST, "PLC 0 (1)")
  field(TWVL, "2")
  field(TWST, "PLC 1-31 (2)")
  field(THVL, "3")
  field(THST, "ALL (3)")
  field(SCAN, "I/O Intr")
}

# I6 Error reporting mode
record(mbbi, "BL45P-MO-STEP-01:ERRREPMODE") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I6")
  field(SCAN, "I/O Intr")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
# the <BELL> character is given for invalid commands
  field(ZRST, "BELL(0)")
#the form of the error message is <BELL>{error message}
  field(ONST, "BELL+ERR(1)")
#the <BELL> character is given only for invalid commands from the host;
# there is no response to invalid commands issued from Turbo PMAC programs.
  field(TWST, "BELL-PRG(2)")
#<BELL><CR>{error message}
  field(THST, "BELL+CR+ERR(3)")
}

# I56 DPRAM ASCII Communications Interrupt
record(bi, "BL45P-MO-STEP-01:DPRAM_COMMS_INT") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I56")
  field(ONAM, "ENABLED")
  field(PINI, "YES")
  field(SCAN, "I/O Intr")
  field(ZNAM, "DISABLED")
}

# I58 DPRAM ASCII Communications Enable
record(bi, "BL45P-MO-STEP-01:DPRAM_COMMS") {
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_I58")
  field(ZNAM, "DISABLED")
  field(ONAM, "ENABLED")
}

# I90 VME Address modifier
record(mbbi, "BL45P-MO-STEP-01:VME_ADDR_MODE") {
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VHS_I90")
  field(ZRVL, "0x29")
  field(ONVL, "0x39")
  field(TWVL, "0x09")
  field(ZRST, "16-bit addr")
  field(ONST, "24-bit addr")
  field(TWST, "32-bit addr")
}

# I97 VME DPRAM Base Address Bits A23-A20
record(longin, "BL45P-MO-STEP-01:VME_DPRAMBASE") {
  field(SCAN, "I/O Intr")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VHS_I97")
  field(PINI, "YES")
}

# I95 VME Interrupt Level
record(longin, "BL45P-MO-STEP-01:VME_INTLVL") {
  field(SCAN, "I/O Intr")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VHS_I95")
  field(PINI, "YES")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS1:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS1:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#1P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS1:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#1F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS1:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#1V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS1:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS1:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS1:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS1:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS1:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS1:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,1)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS1:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS1:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS1:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS1:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,1)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS1:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS1:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS1:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS1:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,1)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS1:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS1:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS1:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS2:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS2:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#2P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS2:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#2F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS2:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#2V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS2:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS2:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS2:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS2:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS2:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS2:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,2)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS2:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS2:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS2:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS2:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,2)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS2:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS2:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS2:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS2:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,2)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS2:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS2:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS2:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS3:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS3:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#3P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS3:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#3F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS3:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#3V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS3:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS3:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS3:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS3:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS3:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS3:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,3)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS3:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS3:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS3:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS3:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,3)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS3:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS3:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS3:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS3:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,3)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS3:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS3:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS3:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS4:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS4:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#4P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS4:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#4F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS4:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#4V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS4:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS4:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS4:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS4:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS4:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS4:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,4)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS4:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS4:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS4:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS4:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,4)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS4:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS4:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS4:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS4:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,4)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS4:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS4:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS4:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS5:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS5:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#5P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS5:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#5F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS5:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#5V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS5:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS5:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS5:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS5:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS5:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS5:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,5)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS5:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS5:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS5:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS5:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,5)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS5:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS5:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS5:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS5:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,5)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS5:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS5:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS5:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS6:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS6:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#6P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS6:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#6F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS6:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#6V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS6:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS6:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS6:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS6:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS6:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS6:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,6)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS6:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS6:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS6:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS6:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,6)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS6:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS6:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS6:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS6:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,6)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS6:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS6:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS6:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS7:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS7:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#7P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS7:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#7F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS7:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#7V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS7:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS7:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS7:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS7:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS7:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS7:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,7)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS7:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS7:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS7:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS7:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,7)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS7:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS7:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS7:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS7:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,7)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS7:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS7:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS7:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BL45P-MO-STEP-01:AXIS8:DESC") {
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:AXIS8:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#8P")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS8:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#8F")
  field(PREC, "2")
}

record(ai, "BL45P-MO-STEP-01:AXIS8:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#8V")
  field(PREC, "2")
}

record(seq, "BL45P-MO-STEP-01:AXIS8:ReadBack") {
  field(LNK1, "BL45P-MO-STEP-01:AXIS8:POSITION.PROC PP")
  field(LNK2, "BL45P-MO-STEP-01:AXIS8:FOLL_ERROR.PROC PP")
  field(LNK3, "BL45P-MO-STEP-01:AXIS8:VELOCITY.PROC PP")
  field(LNK4, "BL45P-MO-STEP-01:AXIS8:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BL45P-MO-STEP-01:AXIS8:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,8)PMAC_C_AXIS_BITS01")
  field(FLNK, "BL45P-MO-STEP-01:AXIS8:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS8:status1") {
  field(INP, "BL45P-MO-STEP-01:AXIS8:READ_STAT1")
}

record(longin, "BL45P-MO-STEP-01:AXIS8:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,8)PMAC_C_AXIS_BITS02")
  field(FLNK, "BL45P-MO-STEP-01:AXIS8:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS8:status2") {
  field(INP, "BL45P-MO-STEP-01:AXIS8:READ_STAT2")
}

record(longin, "BL45P-MO-STEP-01:AXIS8:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(BRICK1,8)PMAC_C_AXIS_BITS03")
  field(FLNK, "BL45P-MO-STEP-01:AXIS8:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BL45P-MO-STEP-01:AXIS8:status3") {
  field(INP, "BL45P-MO-STEP-01:AXIS8:READ_STAT3")
}
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-SAMP-01:THETA, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Sample Theta
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-SAMP-01:THETA

# This associates an edm screen with the template
# % gui, SAMP01.THETA, edm, motor.edl, motor=BL45P-MO-SAMP-01:THETA
# % gui, SAMP01.THETA, edmembed, motor-embed-small.edl, motor=BL45P-MO-SAMP-01:THETA,filename=motor.edl,box-label=Sample Theta

# This associates a BOY screen with the template
# % gui, SAMP01.THETA, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-SAMP-01,M=:THETA,DESC=Sample Theta, name=SAMP01.THETA
# % gui, SAMP01.THETA, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-SAMP-01,M=:THETA,DESC=Sample Theta, name=SAMP01.THETA
# % gui, SAMP01.THETA, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-SAMP-01,M=:THETA,DESC=Sample Theta, name=SAMP01.THETA
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.THETA, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-SAMP-01,M=:THETA

# This makes the component icon reflect the status and severity
# % gui, SAMP01.THETA, status, <pv>.MOVN
# % gui, SAMP01.THETA, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.THETA, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.THETA, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.THETA, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.THETA, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.THETA, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.THETA, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.THETA, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.THETA, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.THETA, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.THETA, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.THETA, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.THETA, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.THETA, command, Stop,  <pv>.STOP
# % gui, SAMP01.THETA, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.THETA, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.THETA, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.THETA, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.THETA, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.THETA, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.THETA, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.THETA, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.THETA, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.THETA, enum, Direction,   <pv>.DIR
# % gui, SAMP01.THETA, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.THETA, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.THETA, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.THETA, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.THETA, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.THETA, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.THETA, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.THETA, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.THETA, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.THETA, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.THETA, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.THETA, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.THETA, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.THETA, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.THETA, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.THETA, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.THETA, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.THETA, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.THETA, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.THETA, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.THETA, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.THETA, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.THETA, demand, PREC,   <pv>.PREC
# % gui, SAMP01.THETA, demand, EGU,   <pv>.EGU

# % gui, SAMP01.THETA, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.THETA, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.THETA, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.THETA, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.THETA, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.THETA, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.THETA, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.THETA, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-SAMP-01:THETA")
{
	field(DESC,"Sample Theta")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"180")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,3)")
	field(MRES,"0.036")
	field(PREC,"3")
	field(EGU,"deg")
	field(DHLM,"10000000")
	field(DLLM,"-10000000")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "180")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "180")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-SAMP-01:THETA:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-SAMP-01:THETA:ADDR") {
    field(PINI, "YES")
    field(VAL, "3")
}

# record that holds the PORT
record(stringout, "BL45P-MO-SAMP-01:THETA:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-SAMP-01:THETA:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-SAMP-01:THETA:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-SAMP-01:THETA:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-SAMP-01:THETA:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-SAMP-01:THETA:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-SAMP-01:THETA.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-SAMP-01:THETA:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-SAMP-01:THETA:ELOSS
record(ai, "BL45P-MO-SAMP-01:THETA:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-SAMP-01:THETA:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-SAMP-01:THETA:CHECK_SYNC") {
  field(INPA, "BL45P-MO-SAMP-01:THETA.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-SAMP-01:THETA:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-SAMP-01:THETA:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-SAMP-01:THETA:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-SAMP-01:THETA.RMP CP")
	field(INPB,"BL45P-MO-SAMP-01:THETA.REP NPP")
	field(INPC,"BL45P-MO-SAMP-01:THETA.MRES NPP")
	field(INPD,"BL45P-MO-SAMP-01:THETA.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-SAMP-01:THETA:FERRORMAX")
	field(PREC,"3")
	field(EGU, "deg")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-SAMP-01:THETA:FERRORMAX
record(calc, "BL45P-MO-SAMP-01:THETA:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-SAMP-01:THETA:FERROR.VAL")
	field(INPB,"BL45P-MO-SAMP-01:THETA:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "deg")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-SAMP-01:THETA:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-SAMP-01:THETA:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-SAMP-01:THETA:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-SAMP-01:THETA:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Absolute Encoder")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-SAMP-01:THETA, BL45P-MO-STEP-01:M3)
alias(BL45P-MO-SAMP-01:THETA:ADDR, BL45P-MO-STEP-01:M3:ADDR)
alias(BL45P-MO-SAMP-01:THETA:PORT, BL45P-MO-STEP-01:M3:PORT)
alias(BL45P-MO-SAMP-01:THETA:SCALE, BL45P-MO-STEP-01:M3:SCALE)
alias(BL45P-MO-SAMP-01:THETA:USER:SDIS, BL45P-MO-STEP-01M3:USER:SDIS)
alias(BL45P-MO-SAMP-01:THETA:SDIS, BL45P-MO-STEP-01:M3:SDIS)
alias(BL45P-MO-SAMP-01:THETA:KILL, BL45P-MO-STEP-01:M3:KILL)
alias(BL45P-MO-SAMP-01:THETA:ELOSS, BL45P-MO-STEP-01:M3:ELOSS)
alias(BL45P-MO-SAMP-01:THETA:ELOSSRC, BL45P-MO-STEP-01:M3:ELOSSRC)
alias(BL45P-MO-SAMP-01:THETA:MR_MOVE_WRITE, BL45P-MO-STEP-01:M3:MR_MOVE_WRITE)
alias(BL45P-MO-SAMP-01:THETA:CHECK_SYNC, BL45P-MO-STEP-01:M3:CHECK_SYNC)
alias(BL45P-MO-SAMP-01:THETA:FERROR, BL45P-MO-STEP-01:M3:FERROR)
alias(BL45P-MO-SAMP-01:THETA:FERRORMAX, BL45P-MO-STEP-01:M3:FERRORMAX)
alias(BL45P-MO-SAMP-01:THETA:FEMAXRESET, BL45P-MO-STEP-01:M3:FEMAXRESET)
alias(BL45P-MO-SAMP-01:THETA:HOMEVIS, BL45P-MO-STEP-01:M3:HOMEVIS)
alias(BL45P-MO-SAMP-01:THETA:HOMEVISSTR, BL45P-MO-STEP-01:M3:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-SAMP-01:THETA:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-SAMP-01:THETA.MRES CP")
  field(INPB, "BL45P-MO-SAMP-01:THETA.DIR CP")
  field(INPC, "BL45P-MO-SAMP-01:THETA:SCALE")
  field(OUT, "BL45P-MO-SAMP-01:THETA:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-SAMP-01:THETA:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+3`")
  field(FLNK, "BL45P-MO-SAMP-01:THETA:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-SAMP-01:THETA:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-SAMP-01:THETA.OFF CP")
  field(OUT, "BL45P-MO-SAMP-01:THETA:OFF_SET PP")
}

record(ao, "BL45P-MO-SAMP-01:THETA:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+3`")
  field(FLNK, "BL45P-MO-SAMP-01:THETA:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-SAMP-01:THETA:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,3)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-SAMP-01:THETA:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-SAMP-01:THETA:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,3)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-SAMP-01:THETA:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-SAMP-01:THETA:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,3)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-SAMP-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-SAMP-01:THETA:SDIS") {
#  field(INPA, "BL45P-MO-SAMP-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-SAMP-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-SAMP-01:THETA:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-SAMP-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-SAMP-01:THETA:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-SAMP-01:THETA:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-SAMP-01:THETA:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-SAMP-01:THETA:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-SAMP-01:THETA:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,3)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-SAMP-01:THETA:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#3P")
  field(DESC, "Sample Theta")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-SAMP-01:THETA:HMPOS:CALC") {
  field(INPA, "BL45P-MO-SAMP-01:THETA.MRES CP")
  field(INPB, "BL45P-MO-SAMP-01:THETA:SCALE")
  field(INPC, "BL45P-MO-SAMP-01:THETA:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-SAMP-01:THETA:HMPOS PP")
}

record(ai, "BL45P-MO-SAMP-01:THETA:HMPOS") {
  field(DESC, "Sample Theta")
  field(PREC, "3")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-SAMP-01:THETA:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-SAMP-01:THETA")
  field(OUT, "BL45P-MO-SAMP-01:HM:M3PV PP")
}

record(stringout, "BL45P-MO-SAMP-01:HM:M3PV"){
}

# define a kill record
record(ao, "BL45P-MO-SAMP-01:THETA:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-SAMP-01:THETA:ELOSSVAR") {
  field(CALC, "464+3")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-SAMP-01:THETA:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+3`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-SAMP-01:THETA:ELOSSRC") {
  field(OUT, "BL45P-MO-SAMP-01:THETA:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-SAMP-01:THETA:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+3`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS3:DESC"){
  field(VAL, "SAMP01.THETA Sample Theta")
}

#record(bo, "BL45P-MO-SAMP-01:THETA:HOMED") {
#  field(DESC, "Set homed status for axis 3")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-SAMP-01:THETA:HOMEDSET")
#}

#record(calcout, "BL45P-MO-SAMP-01:THETA:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-SAMP-01:THETA:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m345) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-SAMP-01:THETA:DirectDemand")
{
    field(FLNK, "BL45P-MO-SAMP-01:THETA:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-SAMP-01:THETA:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-SAMP-01:THETA:DirectDemand")
    field(INPB, "BL45P-MO-SAMP-01:THETA:Mres PP")
    field(INPC, "BL45P-MO-SAMP-01:THETA:Offset PP")
    field(INPD, "BL45P-MO-SAMP-01:THETA:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-SAMP-01:THETA:RawDirectDemand PP")
}

record(ao, "BL45P-MO-SAMP-01:THETA:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-SAMP-01:THETA:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,3,4)MOTOR_MOVE_ABS")
    field(DESC, "Sample Theta")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-SAMP-01:THETA:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-SAMP-01:THETA:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-SAMP-01:THETA:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-SAMP-01:THETA:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-SAMP-01:THETA:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-SAMP-01:THETA:MresSource")
}

record(scalcout, BL45P-MO-SAMP-01:THETA:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-SAMP-01:THETA:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-SAMP-01:THETA:Mres.INPA CA")
    field(FLNK, "BL45P-MO-SAMP-01:THETA:OffsetSource")
}

record(scalcout, "BL45P-MO-SAMP-01:THETA:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-SAMP-01:THETA:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-SAMP-01:THETA:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-SAMP-01:THETA:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-SAMP-01:THETA:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-SAMP-01:THETA:Offset.INPA CA")
}


record(scalcout, BL45P-MO-SAMP-01:THETA:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-SAMP-01:THETA:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-SAMP-01:THETA:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M3:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M3.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M3.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M3:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M3:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M3:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+3`")
  field(FLNK, "BL45P-MO-STEP-01:M3:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M3:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M3.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M3:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M3:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+3`")
  field(FLNK, "BL45P-MO-STEP-01:M3:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M3:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,3)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M3:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M3:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,3)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M3:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M3:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,3)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M3:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M3:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M3:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M3:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M3:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M3:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M3:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,3)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M3:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#3P")
  field(DESC, "Sample Theta")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-STEP-01:M3:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M3.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M3:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M3:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M3:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M3:HMPOS") {
  field(DESC, "Sample Theta")
  field(PREC, "3")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M3:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M3")
  field(OUT, "BL45P-MO-STEP-01::HM:M3PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M3PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M3:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,3)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M3:ELOSSVAR") {
  field(CALC, "464+3")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M3:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+3`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M3:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M3:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M3:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+3`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS3:DESC"){
  field(VAL, "SAMP01.THETA Sample Theta")
}

#record(bo, "BL45P-MO-STEP-01:M3:HOMED") {
#  field(DESC, "Set homed status for axis 3")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M3:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M3:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M3:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m345) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M3:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M3:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M3:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M3:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M3:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M3:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M3:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M3:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M3:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M3:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,3,4)MOTOR_MOVE_ABS")
    field(DESC, "Sample Theta")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M3:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M3:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M3:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M3:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M3:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M3:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M3:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M3:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M3:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M3:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M3:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M3:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M3:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M3:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M3:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M3:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M3:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,3,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-CHOP-01:HOR, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,X Chopper
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:HOR

# This associates an edm screen with the template
# % gui, CHOP01.X, edm, motor.edl, motor=BL45P-MO-CHOP-01:HOR
# % gui, CHOP01.X, edmembed, motor-embed-small.edl, motor=BL45P-MO-CHOP-01:HOR,filename=motor.edl,box-label=X Chopper

# This associates a BOY screen with the template
# % gui, CHOP01.X, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-CHOP-01,M=:HOR,DESC=X Chopper, name=CHOP01.X
# % gui, CHOP01.X, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-CHOP-01,M=:HOR,DESC=X Chopper, name=CHOP01.X
# % gui, CHOP01.X, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-CHOP-01,M=:HOR,DESC=X Chopper, name=CHOP01.X
# FIXME: this should be in pmacUtil or tpmac
# % gui, CHOP01.X, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-CHOP-01,M=:HOR

# This makes the component icon reflect the status and severity
# % gui, CHOP01.X, status, <pv>.MOVN
# % gui, CHOP01.X, sevr

# These define what PVs a motor detail screen should contain
# % gui, CHOP01.X, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, CHOP01.X, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, CHOP01.X, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, CHOP01.X, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, CHOP01.X, statusbits, At High Limit,  <pv>.HLS, High
# % gui, CHOP01.X, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, CHOP01.X, demand, User High Limit,  <pv>.HLM
# % gui, CHOP01.X, demand, User Low Limit,  <pv>.LLM
# % gui, CHOP01.X, demand, Dial High Limit, <pv>.DHLM
# % gui, CHOP01.X, demand, Dial Low Limit, <pv>.DLLM

# % gui, CHOP01.X, demand, Motor demand,  <pv>.VAL
# % gui, CHOP01.X, readback, Motor readback,  <pv>.RBV
# % gui, CHOP01.X, command, Stop,  <pv>.STOP
# % gui, CHOP01.X, command, Home Forward,  <pv>.HOMF
# % gui, CHOP01.X, command, Home Reverse,  <pv>.HOMR
# % gui, CHOP01.X, command, Jog Forward, <pv>.JOGF
# % gui, CHOP01.X, command, Jog Reverse, <pv>.JOGR
# % gui, CHOP01.X, command, Tweak Forward,  <pv>.TWF
# % gui, CHOP01.X, command, Tweak Reverse,  <pv>.TWR
# % gui, CHOP01.X, demand, Tweak Step,  <pv>.TWV
# % gui, CHOP01.X, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, CHOP01.X, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, CHOP01.X, enum, Direction,   <pv>.DIR
# % gui, CHOP01.X, demand, User Offset,  <pv>.OFF
# % gui, CHOP01.X, enum, Set/Use,   <pv>.SET
# % gui, CHOP01.X, enum, Offset,   <pv>.FOFF
# % gui, CHOP01.X, enum, Use Encoder,   <pv>.UEIP

# % gui, CHOP01.X, demand, Motor Step Size,  <pv>.MRES
# % gui, CHOP01.X, readback, Steps per Rev,   <pv>.SREV
# % gui, CHOP01.X, readback, EGUs per Rev,   <pv>.UREV
# % gui, CHOP01.X, demand, Encoder Step Size,  <pv>.ERES
# % gui, CHOP01.X, readback, Readback Step Size,   <pv>.RRES
# % gui, CHOP01.X, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, CHOP01.X, demand, Max Velocity,  <pv>.VMAX
# % gui, CHOP01.X, demand, Base Velocity,   <pv>.VBAS
# % gui, CHOP01.X, demand, Velocity,  <pv>.VELO
# % gui, CHOP01.X, demand, Secs to Velocity,  <pv>.ACCL
# % gui, CHOP01.X, demand, JVEL,   <pv>.JVEL
# % gui, CHOP01.X, demand, Jog Acceleration,   <pv>.JAR
# % gui, CHOP01.X, demand, Backlash Distance,   <pv>.BDST
# % gui, CHOP01.X, demand, Backlash Velocity,   <pv>.BVEL
# % gui, CHOP01.X, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, CHOP01.X, demand, Move Fraction,   <pv>.FRAC
# % gui, CHOP01.X, demand, Retry Deadband,   <pv>.RDBD
# % gui, CHOP01.X, demand, Max Retrys,   <pv>.RTRY

# % gui, CHOP01.X, demand, PREC,   <pv>.PREC
# % gui, CHOP01.X, demand, EGU,   <pv>.EGU

# % gui, CHOP01.X, demand, Output Specification,   <pv>.OUT
# % gui, CHOP01.X, readback, Readback Location,   <pv>.RDBL
# % gui, CHOP01.X, readback, Desired Output Loc,   <pv>.DOL
# % gui, CHOP01.X, readback, Output Mode Select,   <pv>.OMSL
# % gui, CHOP01.X, readback, Readback Out Link,   <pv>.RLNK
# % gui, CHOP01.X, demand, DMOV Input Link,   <pv>.DINP
# % gui, CHOP01.X, demand, RMP Input Link,   <pv>.RINP
# % gui, CHOP01.X, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-CHOP-01:HOR")
{
	field(DESC,"X Chopper")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"43")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,4)")
	field(MRES,"0.000043")
	field(PREC,"5")
	field(EGU,"deg")
	field(DHLM,"10000000")
	field(DLLM,"-10000000")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "43")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "43")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-CHOP-01:HOR:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-CHOP-01:HOR:ADDR") {
    field(PINI, "YES")
    field(VAL, "4")
}

# record that holds the PORT
record(stringout, "BL45P-MO-CHOP-01:HOR:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-CHOP-01:HOR:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-CHOP-01:HOR:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-CHOP-01:HOR:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-CHOP-01:HOR:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-CHOP-01:HOR:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-CHOP-01:HOR.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-CHOP-01:HOR:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:HOR:ELOSS
record(ai, "BL45P-MO-CHOP-01:HOR:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-CHOP-01:HOR:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-CHOP-01:HOR:CHECK_SYNC") {
  field(INPA, "BL45P-MO-CHOP-01:HOR.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-CHOP-01:HOR:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-CHOP-01:HOR:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-CHOP-01:HOR:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-CHOP-01:HOR.RMP CP")
	field(INPB,"BL45P-MO-CHOP-01:HOR.REP NPP")
	field(INPC,"BL45P-MO-CHOP-01:HOR.MRES NPP")
	field(INPD,"BL45P-MO-CHOP-01:HOR.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-CHOP-01:HOR:FERRORMAX")
	field(PREC,"5")
	field(EGU, "deg")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:HOR:FERRORMAX
record(calc, "BL45P-MO-CHOP-01:HOR:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-CHOP-01:HOR:FERROR.VAL")
	field(INPB,"BL45P-MO-CHOP-01:HOR:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"5")
	field(EGU, "deg")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-CHOP-01:HOR:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-CHOP-01:HOR:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-CHOP-01:HOR:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "0")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-CHOP-01:HOR:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Absolute Encoder")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-CHOP-01:HOR, BL45P-MO-STEP-01:M4)
alias(BL45P-MO-CHOP-01:HOR:ADDR, BL45P-MO-STEP-01:M4:ADDR)
alias(BL45P-MO-CHOP-01:HOR:PORT, BL45P-MO-STEP-01:M4:PORT)
alias(BL45P-MO-CHOP-01:HOR:SCALE, BL45P-MO-STEP-01:M4:SCALE)
alias(BL45P-MO-CHOP-01:HOR:USER:SDIS, BL45P-MO-STEP-01M4:USER:SDIS)
alias(BL45P-MO-CHOP-01:HOR:SDIS, BL45P-MO-STEP-01:M4:SDIS)
alias(BL45P-MO-CHOP-01:HOR:KILL, BL45P-MO-STEP-01:M4:KILL)
alias(BL45P-MO-CHOP-01:HOR:ELOSS, BL45P-MO-STEP-01:M4:ELOSS)
alias(BL45P-MO-CHOP-01:HOR:ELOSSRC, BL45P-MO-STEP-01:M4:ELOSSRC)
alias(BL45P-MO-CHOP-01:HOR:MR_MOVE_WRITE, BL45P-MO-STEP-01:M4:MR_MOVE_WRITE)
alias(BL45P-MO-CHOP-01:HOR:CHECK_SYNC, BL45P-MO-STEP-01:M4:CHECK_SYNC)
alias(BL45P-MO-CHOP-01:HOR:FERROR, BL45P-MO-STEP-01:M4:FERROR)
alias(BL45P-MO-CHOP-01:HOR:FERRORMAX, BL45P-MO-STEP-01:M4:FERRORMAX)
alias(BL45P-MO-CHOP-01:HOR:FEMAXRESET, BL45P-MO-STEP-01:M4:FEMAXRESET)
alias(BL45P-MO-CHOP-01:HOR:HOMEVIS, BL45P-MO-STEP-01:M4:HOMEVIS)
alias(BL45P-MO-CHOP-01:HOR:HOMEVISSTR, BL45P-MO-STEP-01:M4:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-CHOP-01:HOR:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-CHOP-01:HOR.MRES CP")
  field(INPB, "BL45P-MO-CHOP-01:HOR.DIR CP")
  field(INPC, "BL45P-MO-CHOP-01:HOR:SCALE")
  field(OUT, "BL45P-MO-CHOP-01:HOR:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-CHOP-01:HOR:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+4`")
  field(FLNK, "BL45P-MO-CHOP-01:HOR:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-CHOP-01:HOR:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-CHOP-01:HOR.OFF CP")
  field(OUT, "BL45P-MO-CHOP-01:HOR:OFF_SET PP")
}

record(ao, "BL45P-MO-CHOP-01:HOR:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+4`")
  field(FLNK, "BL45P-MO-CHOP-01:HOR:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-CHOP-01:HOR:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,4)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-CHOP-01:HOR:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-CHOP-01:HOR:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,4)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-CHOP-01:HOR:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-CHOP-01:HOR:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,4)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-CHOP-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-CHOP-01:HOR:SDIS") {
#  field(INPA, "BL45P-MO-CHOP-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-CHOP-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-CHOP-01:HOR:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-CHOP-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-CHOP-01:HOR:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-CHOP-01:HOR:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-CHOP-01:HOR:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-CHOP-01:HOR:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-CHOP-01:HOR:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,4)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-CHOP-01:HOR:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#4P")
  field(DESC, "X Chopper")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "5")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-CHOP-01:HOR:HMPOS:CALC") {
  field(INPA, "BL45P-MO-CHOP-01:HOR.MRES CP")
  field(INPB, "BL45P-MO-CHOP-01:HOR:SCALE")
  field(INPC, "BL45P-MO-CHOP-01:HOR:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-CHOP-01:HOR:HMPOS PP")
}

record(ai, "BL45P-MO-CHOP-01:HOR:HMPOS") {
  field(DESC, "X Chopper")
  field(PREC, "5")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-CHOP-01:HOR:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-CHOP-01:HOR")
  field(OUT, "BL45P-MO-CHOP-01:HM:M4PV PP")
}

record(stringout, "BL45P-MO-CHOP-01:HM:M4PV"){
}

# define a kill record
record(ao, "BL45P-MO-CHOP-01:HOR:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-CHOP-01:HOR:ELOSSVAR") {
  field(CALC, "464+4")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-CHOP-01:HOR:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+4`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-CHOP-01:HOR:ELOSSRC") {
  field(OUT, "BL45P-MO-CHOP-01:HOR:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-CHOP-01:HOR:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+4`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS4:DESC"){
  field(VAL, "CHOP01.X X Chopper")
}

#record(bo, "BL45P-MO-CHOP-01:HOR:HOMED") {
#  field(DESC, "Set homed status for axis 4")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-CHOP-01:HOR:HOMEDSET")
#}

#record(calcout, "BL45P-MO-CHOP-01:HOR:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-CHOP-01:HOR:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m445) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-CHOP-01:HOR:DirectDemand")
{
    field(FLNK, "BL45P-MO-CHOP-01:HOR:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-CHOP-01:HOR:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-CHOP-01:HOR:DirectDemand")
    field(INPB, "BL45P-MO-CHOP-01:HOR:Mres PP")
    field(INPC, "BL45P-MO-CHOP-01:HOR:Offset PP")
    field(INPD, "BL45P-MO-CHOP-01:HOR:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-CHOP-01:HOR:RawDirectDemand PP")
}

record(ao, "BL45P-MO-CHOP-01:HOR:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-CHOP-01:HOR:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,4,4)MOTOR_MOVE_ABS")
    field(DESC, "X Chopper")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-CHOP-01:HOR:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-CHOP-01:HOR:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-CHOP-01:HOR:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-CHOP-01:HOR:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-CHOP-01:HOR:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-CHOP-01:HOR:MresSource")
}

record(scalcout, BL45P-MO-CHOP-01:HOR:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-CHOP-01:HOR:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-CHOP-01:HOR:Mres.INPA CA")
    field(FLNK, "BL45P-MO-CHOP-01:HOR:OffsetSource")
}

record(scalcout, "BL45P-MO-CHOP-01:HOR:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-CHOP-01:HOR:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-CHOP-01:HOR:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-CHOP-01:HOR:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-CHOP-01:HOR:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-CHOP-01:HOR:Offset.INPA CA")
}


record(scalcout, BL45P-MO-CHOP-01:HOR:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-CHOP-01:HOR:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-CHOP-01:HOR:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M4:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M4.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M4.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M4:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M4:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M4:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+4`")
  field(FLNK, "BL45P-MO-STEP-01:M4:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M4:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M4.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M4:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M4:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+4`")
  field(FLNK, "BL45P-MO-STEP-01:M4:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M4:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,4)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M4:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M4:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,4)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M4:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M4:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,4)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M4:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M4:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M4:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M4:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M4:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M4:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M4:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,4)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M4:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#4P")
  field(DESC, "X Chopper")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "5")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-STEP-01:M4:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M4.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M4:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M4:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M4:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M4:HMPOS") {
  field(DESC, "X Chopper")
  field(PREC, "5")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M4:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M4")
  field(OUT, "BL45P-MO-STEP-01::HM:M4PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M4PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M4:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,4)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M4:ELOSSVAR") {
  field(CALC, "464+4")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M4:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+4`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M4:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M4:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M4:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+4`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS4:DESC"){
  field(VAL, "CHOP01.X X Chopper")
}

#record(bo, "BL45P-MO-STEP-01:M4:HOMED") {
#  field(DESC, "Set homed status for axis 4")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M4:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M4:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M4:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m445) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M4:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M4:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M4:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M4:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M4:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M4:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M4:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M4:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M4:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M4:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,4,4)MOTOR_MOVE_ABS")
    field(DESC, "X Chopper")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M4:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M4:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M4:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M4:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M4:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M4:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M4:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M4:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M4:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M4:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M4:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M4:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M4:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M4:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M4:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M4:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M4:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,4,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-CHOP-01:VER, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Y Chopper
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:VER

# This associates an edm screen with the template
# % gui, CHOP01.Y, edm, motor.edl, motor=BL45P-MO-CHOP-01:VER
# % gui, CHOP01.Y, edmembed, motor-embed-small.edl, motor=BL45P-MO-CHOP-01:VER,filename=motor.edl,box-label=Y Chopper

# This associates a BOY screen with the template
# % gui, CHOP01.Y, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-CHOP-01,M=:VER,DESC=Y Chopper, name=CHOP01.Y
# % gui, CHOP01.Y, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-CHOP-01,M=:VER,DESC=Y Chopper, name=CHOP01.Y
# % gui, CHOP01.Y, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-CHOP-01,M=:VER,DESC=Y Chopper, name=CHOP01.Y
# FIXME: this should be in pmacUtil or tpmac
# % gui, CHOP01.Y, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-CHOP-01,M=:VER

# This makes the component icon reflect the status and severity
# % gui, CHOP01.Y, status, <pv>.MOVN
# % gui, CHOP01.Y, sevr

# These define what PVs a motor detail screen should contain
# % gui, CHOP01.Y, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, CHOP01.Y, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, CHOP01.Y, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, CHOP01.Y, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, CHOP01.Y, statusbits, At High Limit,  <pv>.HLS, High
# % gui, CHOP01.Y, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, CHOP01.Y, demand, User High Limit,  <pv>.HLM
# % gui, CHOP01.Y, demand, User Low Limit,  <pv>.LLM
# % gui, CHOP01.Y, demand, Dial High Limit, <pv>.DHLM
# % gui, CHOP01.Y, demand, Dial Low Limit, <pv>.DLLM

# % gui, CHOP01.Y, demand, Motor demand,  <pv>.VAL
# % gui, CHOP01.Y, readback, Motor readback,  <pv>.RBV
# % gui, CHOP01.Y, command, Stop,  <pv>.STOP
# % gui, CHOP01.Y, command, Home Forward,  <pv>.HOMF
# % gui, CHOP01.Y, command, Home Reverse,  <pv>.HOMR
# % gui, CHOP01.Y, command, Jog Forward, <pv>.JOGF
# % gui, CHOP01.Y, command, Jog Reverse, <pv>.JOGR
# % gui, CHOP01.Y, command, Tweak Forward,  <pv>.TWF
# % gui, CHOP01.Y, command, Tweak Reverse,  <pv>.TWR
# % gui, CHOP01.Y, demand, Tweak Step,  <pv>.TWV
# % gui, CHOP01.Y, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, CHOP01.Y, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, CHOP01.Y, enum, Direction,   <pv>.DIR
# % gui, CHOP01.Y, demand, User Offset,  <pv>.OFF
# % gui, CHOP01.Y, enum, Set/Use,   <pv>.SET
# % gui, CHOP01.Y, enum, Offset,   <pv>.FOFF
# % gui, CHOP01.Y, enum, Use Encoder,   <pv>.UEIP

# % gui, CHOP01.Y, demand, Motor Step Size,  <pv>.MRES
# % gui, CHOP01.Y, readback, Steps per Rev,   <pv>.SREV
# % gui, CHOP01.Y, readback, EGUs per Rev,   <pv>.UREV
# % gui, CHOP01.Y, demand, Encoder Step Size,  <pv>.ERES
# % gui, CHOP01.Y, readback, Readback Step Size,   <pv>.RRES
# % gui, CHOP01.Y, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, CHOP01.Y, demand, Max Velocity,  <pv>.VMAX
# % gui, CHOP01.Y, demand, Base Velocity,   <pv>.VBAS
# % gui, CHOP01.Y, demand, Velocity,  <pv>.VELO
# % gui, CHOP01.Y, demand, Secs to Velocity,  <pv>.ACCL
# % gui, CHOP01.Y, demand, JVEL,   <pv>.JVEL
# % gui, CHOP01.Y, demand, Jog Acceleration,   <pv>.JAR
# % gui, CHOP01.Y, demand, Backlash Distance,   <pv>.BDST
# % gui, CHOP01.Y, demand, Backlash Velocity,   <pv>.BVEL
# % gui, CHOP01.Y, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, CHOP01.Y, demand, Move Fraction,   <pv>.FRAC
# % gui, CHOP01.Y, demand, Retry Deadband,   <pv>.RDBD
# % gui, CHOP01.Y, demand, Max Retrys,   <pv>.RTRY

# % gui, CHOP01.Y, demand, PREC,   <pv>.PREC
# % gui, CHOP01.Y, demand, EGU,   <pv>.EGU

# % gui, CHOP01.Y, demand, Output Specification,   <pv>.OUT
# % gui, CHOP01.Y, readback, Readback Location,   <pv>.RDBL
# % gui, CHOP01.Y, readback, Desired Output Loc,   <pv>.DOL
# % gui, CHOP01.Y, readback, Output Mode Select,   <pv>.OMSL
# % gui, CHOP01.Y, readback, Readback Out Link,   <pv>.RLNK
# % gui, CHOP01.Y, demand, DMOV Input Link,   <pv>.DINP
# % gui, CHOP01.Y, demand, RMP Input Link,   <pv>.RINP
# % gui, CHOP01.Y, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-CHOP-01:VER")
{
	field(DESC,"Y Chopper")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"720")
	field(VBAS,"0")
	field(ACCL,"0.01")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,5)")
	field(MRES,"0.000687")
	field(PREC,"5")
	field(EGU,"deg")
	field(DHLM,"10000000")
	field(DLLM,"-10000000")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "720")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "720")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-CHOP-01:VER:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-CHOP-01:VER:ADDR") {
    field(PINI, "YES")
    field(VAL, "5")
}

# record that holds the PORT
record(stringout, "BL45P-MO-CHOP-01:VER:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-CHOP-01:VER:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-CHOP-01:VER:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-CHOP-01:VER:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-CHOP-01:VER:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-CHOP-01:VER:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-CHOP-01:VER.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-CHOP-01:VER:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:VER:ELOSS
record(ai, "BL45P-MO-CHOP-01:VER:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-CHOP-01:VER:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-CHOP-01:VER:CHECK_SYNC") {
  field(INPA, "BL45P-MO-CHOP-01:VER.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-CHOP-01:VER:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-CHOP-01:VER:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-CHOP-01:VER:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-CHOP-01:VER.RMP CP")
	field(INPB,"BL45P-MO-CHOP-01:VER.REP NPP")
	field(INPC,"BL45P-MO-CHOP-01:VER.MRES NPP")
	field(INPD,"BL45P-MO-CHOP-01:VER.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-CHOP-01:VER:FERRORMAX")
	field(PREC,"5")
	field(EGU, "deg")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-CHOP-01:VER:FERRORMAX
record(calc, "BL45P-MO-CHOP-01:VER:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-CHOP-01:VER:FERROR.VAL")
	field(INPB,"BL45P-MO-CHOP-01:VER:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"5")
	field(EGU, "deg")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-CHOP-01:VER:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-CHOP-01:VER:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-CHOP-01:VER:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "0")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-CHOP-01:VER:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Absolute Encoder")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-CHOP-01:VER, BL45P-MO-STEP-01:M5)
alias(BL45P-MO-CHOP-01:VER:ADDR, BL45P-MO-STEP-01:M5:ADDR)
alias(BL45P-MO-CHOP-01:VER:PORT, BL45P-MO-STEP-01:M5:PORT)
alias(BL45P-MO-CHOP-01:VER:SCALE, BL45P-MO-STEP-01:M5:SCALE)
alias(BL45P-MO-CHOP-01:VER:USER:SDIS, BL45P-MO-STEP-01M5:USER:SDIS)
alias(BL45P-MO-CHOP-01:VER:SDIS, BL45P-MO-STEP-01:M5:SDIS)
alias(BL45P-MO-CHOP-01:VER:KILL, BL45P-MO-STEP-01:M5:KILL)
alias(BL45P-MO-CHOP-01:VER:ELOSS, BL45P-MO-STEP-01:M5:ELOSS)
alias(BL45P-MO-CHOP-01:VER:ELOSSRC, BL45P-MO-STEP-01:M5:ELOSSRC)
alias(BL45P-MO-CHOP-01:VER:MR_MOVE_WRITE, BL45P-MO-STEP-01:M5:MR_MOVE_WRITE)
alias(BL45P-MO-CHOP-01:VER:CHECK_SYNC, BL45P-MO-STEP-01:M5:CHECK_SYNC)
alias(BL45P-MO-CHOP-01:VER:FERROR, BL45P-MO-STEP-01:M5:FERROR)
alias(BL45P-MO-CHOP-01:VER:FERRORMAX, BL45P-MO-STEP-01:M5:FERRORMAX)
alias(BL45P-MO-CHOP-01:VER:FEMAXRESET, BL45P-MO-STEP-01:M5:FEMAXRESET)
alias(BL45P-MO-CHOP-01:VER:HOMEVIS, BL45P-MO-STEP-01:M5:HOMEVIS)
alias(BL45P-MO-CHOP-01:VER:HOMEVISSTR, BL45P-MO-STEP-01:M5:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-CHOP-01:VER:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-CHOP-01:VER.MRES CP")
  field(INPB, "BL45P-MO-CHOP-01:VER.DIR CP")
  field(INPC, "BL45P-MO-CHOP-01:VER:SCALE")
  field(OUT, "BL45P-MO-CHOP-01:VER:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-CHOP-01:VER:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+5`")
  field(FLNK, "BL45P-MO-CHOP-01:VER:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-CHOP-01:VER:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-CHOP-01:VER.OFF CP")
  field(OUT, "BL45P-MO-CHOP-01:VER:OFF_SET PP")
}

record(ao, "BL45P-MO-CHOP-01:VER:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+5`")
  field(FLNK, "BL45P-MO-CHOP-01:VER:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-CHOP-01:VER:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,5)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-CHOP-01:VER:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-CHOP-01:VER:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,5)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-CHOP-01:VER:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-CHOP-01:VER:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,5)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-CHOP-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-CHOP-01:VER:SDIS") {
#  field(INPA, "BL45P-MO-CHOP-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-CHOP-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-CHOP-01:VER:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-CHOP-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-CHOP-01:VER:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-CHOP-01:VER:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-CHOP-01:VER:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-CHOP-01:VER:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-CHOP-01:VER:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,5)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-CHOP-01:VER:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#5P")
  field(DESC, "Y Chopper")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "5")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-CHOP-01:VER:HMPOS:CALC") {
  field(INPA, "BL45P-MO-CHOP-01:VER.MRES CP")
  field(INPB, "BL45P-MO-CHOP-01:VER:SCALE")
  field(INPC, "BL45P-MO-CHOP-01:VER:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-CHOP-01:VER:HMPOS PP")
}

record(ai, "BL45P-MO-CHOP-01:VER:HMPOS") {
  field(DESC, "Y Chopper")
  field(PREC, "5")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-CHOP-01:VER:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-CHOP-01:VER")
  field(OUT, "BL45P-MO-CHOP-01:HM:M5PV PP")
}

record(stringout, "BL45P-MO-CHOP-01:HM:M5PV"){
}

# define a kill record
record(ao, "BL45P-MO-CHOP-01:VER:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-CHOP-01:VER:ELOSSVAR") {
  field(CALC, "464+5")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-CHOP-01:VER:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+5`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-CHOP-01:VER:ELOSSRC") {
  field(OUT, "BL45P-MO-CHOP-01:VER:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-CHOP-01:VER:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+5`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS5:DESC"){
  field(VAL, "CHOP01.Y Y Chopper")
}

#record(bo, "BL45P-MO-CHOP-01:VER:HOMED") {
#  field(DESC, "Set homed status for axis 5")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-CHOP-01:VER:HOMEDSET")
#}

#record(calcout, "BL45P-MO-CHOP-01:VER:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-CHOP-01:VER:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m545) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-CHOP-01:VER:DirectDemand")
{
    field(FLNK, "BL45P-MO-CHOP-01:VER:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-CHOP-01:VER:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-CHOP-01:VER:DirectDemand")
    field(INPB, "BL45P-MO-CHOP-01:VER:Mres PP")
    field(INPC, "BL45P-MO-CHOP-01:VER:Offset PP")
    field(INPD, "BL45P-MO-CHOP-01:VER:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-CHOP-01:VER:RawDirectDemand PP")
}

record(ao, "BL45P-MO-CHOP-01:VER:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-CHOP-01:VER:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,5,4)MOTOR_MOVE_ABS")
    field(DESC, "Y Chopper")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-CHOP-01:VER:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-CHOP-01:VER:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-CHOP-01:VER:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-CHOP-01:VER:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-CHOP-01:VER:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-CHOP-01:VER:MresSource")
}

record(scalcout, BL45P-MO-CHOP-01:VER:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-CHOP-01:VER:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-CHOP-01:VER:Mres.INPA CA")
    field(FLNK, "BL45P-MO-CHOP-01:VER:OffsetSource")
}

record(scalcout, "BL45P-MO-CHOP-01:VER:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-CHOP-01:VER:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-CHOP-01:VER:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-CHOP-01:VER:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-CHOP-01:VER:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-CHOP-01:VER:Offset.INPA CA")
}


record(scalcout, BL45P-MO-CHOP-01:VER:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-CHOP-01:VER:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-CHOP-01:VER:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M5:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M5.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M5.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M5:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M5:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M5:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+5`")
  field(FLNK, "BL45P-MO-STEP-01:M5:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M5:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M5.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M5:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M5:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+5`")
  field(FLNK, "BL45P-MO-STEP-01:M5:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M5:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,5)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M5:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M5:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,5)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M5:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M5:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,5)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M5:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M5:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M5:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M5:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M5:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M5:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M5:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,5)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M5:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#5P")
  field(DESC, "Y Chopper")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "5")
  field(EGU, "deg")
}

record(calcout, "BL45P-MO-STEP-01:M5:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M5.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M5:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M5:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M5:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M5:HMPOS") {
  field(DESC, "Y Chopper")
  field(PREC, "5")
  field(EGU, "deg")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M5:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M5")
  field(OUT, "BL45P-MO-STEP-01::HM:M5PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M5PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M5:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,5)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M5:ELOSSVAR") {
  field(CALC, "464+5")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M5:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+5`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M5:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M5:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M5:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+5`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS5:DESC"){
  field(VAL, "CHOP01.Y Y Chopper")
}

#record(bo, "BL45P-MO-STEP-01:M5:HOMED") {
#  field(DESC, "Set homed status for axis 5")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M5:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M5:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M5:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m545) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M5:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M5:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M5:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M5:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M5:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M5:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M5:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M5:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M5:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M5:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,5,4)MOTOR_MOVE_ABS")
    field(DESC, "Y Chopper")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M5:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M5:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M5:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M5:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M5:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M5:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M5:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M5:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M5:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M5:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M5:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M5:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M5:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M5:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M5:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M5:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M5:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,5,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-STAGE-01:X, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,X Stage
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:X

# This associates an edm screen with the template
# % gui, SAMP01.X, edm, motor.edl, motor=BL45P-MO-STAGE-01:X
# % gui, SAMP01.X, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:X,filename=motor.edl,box-label=X Stage

# This associates a BOY screen with the template
# % gui, SAMP01.X, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:X,DESC=X Stage, name=SAMP01.X
# % gui, SAMP01.X, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:X,DESC=X Stage, name=SAMP01.X
# % gui, SAMP01.X, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:X,DESC=X Stage, name=SAMP01.X
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.X, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:X

# This makes the component icon reflect the status and severity
# % gui, SAMP01.X, status, <pv>.MOVN
# % gui, SAMP01.X, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.X, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.X, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.X, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.X, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.X, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.X, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.X, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.X, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.X, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.X, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.X, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.X, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.X, command, Stop,  <pv>.STOP
# % gui, SAMP01.X, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.X, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.X, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.X, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.X, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.X, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.X, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.X, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.X, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.X, enum, Direction,   <pv>.DIR
# % gui, SAMP01.X, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.X, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.X, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.X, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.X, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.X, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.X, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.X, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.X, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.X, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.X, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.X, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.X, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.X, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.X, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.X, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.X, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.X, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.X, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.X, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.X, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.X, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.X, demand, PREC,   <pv>.PREC
# % gui, SAMP01.X, demand, EGU,   <pv>.EGU

# % gui, SAMP01.X, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.X, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.X, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.X, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.X, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.X, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.X, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.X, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:X")
{
	field(DESC,"X Stage")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,6)")
	field(MRES,"0.0001")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"50.5")
	field(DLLM,"0.1")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:X:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:X:ADDR") {
    field(PINI, "YES")
    field(VAL, "6")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:X:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:X:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:X:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:X:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:X:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:X:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:X.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:X:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:X:ELOSS
record(ai, "BL45P-MO-STAGE-01:X:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:X:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:X:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:X.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:X:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:X:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:X:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:X.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:X.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:X.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:X.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:X:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:X:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:X:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:X:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:X:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:X:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:X:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:X:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:X:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-STAGE-01:X, BL45P-MO-STEP-01:M6)
alias(BL45P-MO-STAGE-01:X:ADDR, BL45P-MO-STEP-01:M6:ADDR)
alias(BL45P-MO-STAGE-01:X:PORT, BL45P-MO-STEP-01:M6:PORT)
alias(BL45P-MO-STAGE-01:X:SCALE, BL45P-MO-STEP-01:M6:SCALE)
alias(BL45P-MO-STAGE-01:X:USER:SDIS, BL45P-MO-STEP-01M6:USER:SDIS)
alias(BL45P-MO-STAGE-01:X:SDIS, BL45P-MO-STEP-01:M6:SDIS)
alias(BL45P-MO-STAGE-01:X:KILL, BL45P-MO-STEP-01:M6:KILL)
alias(BL45P-MO-STAGE-01:X:ELOSS, BL45P-MO-STEP-01:M6:ELOSS)
alias(BL45P-MO-STAGE-01:X:ELOSSRC, BL45P-MO-STEP-01:M6:ELOSSRC)
alias(BL45P-MO-STAGE-01:X:MR_MOVE_WRITE, BL45P-MO-STEP-01:M6:MR_MOVE_WRITE)
alias(BL45P-MO-STAGE-01:X:CHECK_SYNC, BL45P-MO-STEP-01:M6:CHECK_SYNC)
alias(BL45P-MO-STAGE-01:X:FERROR, BL45P-MO-STEP-01:M6:FERROR)
alias(BL45P-MO-STAGE-01:X:FERRORMAX, BL45P-MO-STEP-01:M6:FERRORMAX)
alias(BL45P-MO-STAGE-01:X:FEMAXRESET, BL45P-MO-STEP-01:M6:FEMAXRESET)
alias(BL45P-MO-STAGE-01:X:HOMEVIS, BL45P-MO-STEP-01:M6:HOMEVIS)
alias(BL45P-MO-STAGE-01:X:HOMEVISSTR, BL45P-MO-STEP-01:M6:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STAGE-01:X:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STAGE-01:X.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:X.DIR CP")
  field(INPC, "BL45P-MO-STAGE-01:X:SCALE")
  field(OUT, "BL45P-MO-STAGE-01:X:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STAGE-01:X:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+6`")
  field(FLNK, "BL45P-MO-STAGE-01:X:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STAGE-01:X:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STAGE-01:X.OFF CP")
  field(OUT, "BL45P-MO-STAGE-01:X:OFF_SET PP")
}

record(ao, "BL45P-MO-STAGE-01:X:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+6`")
  field(FLNK, "BL45P-MO-STAGE-01:X:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STAGE-01:X:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,6)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STAGE-01:X:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STAGE-01:X:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,6)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STAGE-01:X:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STAGE-01:X:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,6)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STAGE-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STAGE-01:X:SDIS") {
#  field(INPA, "BL45P-MO-STAGE-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STAGE-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STAGE-01:X:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STAGE-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-STAGE-01:X:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STAGE-01:X:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STAGE-01:X:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STAGE-01:X:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STAGE-01:X:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,6)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STAGE-01:X:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#6P")
  field(DESC, "X Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STAGE-01:X:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STAGE-01:X.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:X:SCALE")
  field(INPC, "BL45P-MO-STAGE-01:X:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STAGE-01:X:HMPOS PP")
}

record(ai, "BL45P-MO-STAGE-01:X:HMPOS") {
  field(DESC, "X Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STAGE-01:X:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STAGE-01:X")
  field(OUT, "BL45P-MO-STAGE-01:HM:M6PV PP")
}

record(stringout, "BL45P-MO-STAGE-01:HM:M6PV"){
}

# define a kill record
record(ao, "BL45P-MO-STAGE-01:X:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STAGE-01:X:ELOSSVAR") {
  field(CALC, "464+6")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STAGE-01:X:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+6`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STAGE-01:X:ELOSSRC") {
  field(OUT, "BL45P-MO-STAGE-01:X:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STAGE-01:X:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+6`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS6:DESC"){
  field(VAL, "SAMP01.X X Stage")
}

#record(bo, "BL45P-MO-STAGE-01:X:HOMED") {
#  field(DESC, "Set homed status for axis 6")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STAGE-01:X:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STAGE-01:X:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STAGE-01:X:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m645) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STAGE-01:X:DirectDemand")
{
    field(FLNK, "BL45P-MO-STAGE-01:X:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STAGE-01:X:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STAGE-01:X:DirectDemand")
    field(INPB, "BL45P-MO-STAGE-01:X:Mres PP")
    field(INPC, "BL45P-MO-STAGE-01:X:Offset PP")
    field(INPD, "BL45P-MO-STAGE-01:X:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STAGE-01:X:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STAGE-01:X:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STAGE-01:X:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,6,4)MOTOR_MOVE_ABS")
    field(DESC, "X Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STAGE-01:X:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STAGE-01:X:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STAGE-01:X:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STAGE-01:X:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STAGE-01:X:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STAGE-01:X:MresSource")
}

record(scalcout, BL45P-MO-STAGE-01:X:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:X:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STAGE-01:X:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STAGE-01:X:OffsetSource")
}

record(scalcout, "BL45P-MO-STAGE-01:X:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:X:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STAGE-01:X:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STAGE-01:X:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:X:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STAGE-01:X:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STAGE-01:X:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:X:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STAGE-01:X:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M6:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M6.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M6.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M6:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M6:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M6:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+6`")
  field(FLNK, "BL45P-MO-STEP-01:M6:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M6:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M6.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M6:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M6:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+6`")
  field(FLNK, "BL45P-MO-STEP-01:M6:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M6:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,6)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M6:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M6:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,6)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M6:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M6:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,6)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M6:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M6:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M6:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M6:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M6:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M6:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M6:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,6)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M6:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#6P")
  field(DESC, "X Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STEP-01:M6:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M6.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M6:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M6:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M6:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M6:HMPOS") {
  field(DESC, "X Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M6:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M6")
  field(OUT, "BL45P-MO-STEP-01::HM:M6PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M6PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M6:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,6)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M6:ELOSSVAR") {
  field(CALC, "464+6")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M6:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+6`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M6:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M6:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M6:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+6`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS6:DESC"){
  field(VAL, "SAMP01.X X Stage")
}

#record(bo, "BL45P-MO-STEP-01:M6:HOMED") {
#  field(DESC, "Set homed status for axis 6")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M6:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M6:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M6:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m645) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M6:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M6:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M6:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M6:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M6:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M6:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M6:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M6:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M6:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M6:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,6,4)MOTOR_MOVE_ABS")
    field(DESC, "X Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M6:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M6:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M6:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M6:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M6:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M6:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M6:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M6:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M6:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M6:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M6:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M6:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M6:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M6:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M6:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M6:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M6:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,6,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-STAGE-01:Y, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Y Stage
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Y

# This associates an edm screen with the template
# % gui, SAMP01.Y, edm, motor.edl, motor=BL45P-MO-STAGE-01:Y
# % gui, SAMP01.Y, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:Y,filename=motor.edl,box-label=Y Stage

# This associates a BOY screen with the template
# % gui, SAMP01.Y, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:Y,DESC=Y Stage, name=SAMP01.Y
# % gui, SAMP01.Y, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:Y,DESC=Y Stage, name=SAMP01.Y
# % gui, SAMP01.Y, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:Y,DESC=Y Stage, name=SAMP01.Y
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.Y, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:Y

# This makes the component icon reflect the status and severity
# % gui, SAMP01.Y, status, <pv>.MOVN
# % gui, SAMP01.Y, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.Y, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.Y, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.Y, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.Y, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.Y, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.Y, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.Y, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.Y, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.Y, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.Y, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.Y, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.Y, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.Y, command, Stop,  <pv>.STOP
# % gui, SAMP01.Y, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.Y, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.Y, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.Y, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.Y, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.Y, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.Y, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.Y, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.Y, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.Y, enum, Direction,   <pv>.DIR
# % gui, SAMP01.Y, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.Y, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.Y, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.Y, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.Y, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.Y, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.Y, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.Y, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.Y, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.Y, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.Y, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.Y, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.Y, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.Y, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.Y, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.Y, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.Y, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.Y, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.Y, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.Y, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.Y, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.Y, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.Y, demand, PREC,   <pv>.PREC
# % gui, SAMP01.Y, demand, EGU,   <pv>.EGU

# % gui, SAMP01.Y, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.Y, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.Y, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.Y, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.Y, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.Y, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.Y, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.Y, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:Y")
{
	field(DESC,"Y Stage")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,7)")
	field(MRES,"0.0005")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"12")
	field(DLLM,"-0.05")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:Y:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:Y:ADDR") {
    field(PINI, "YES")
    field(VAL, "7")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:Y:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:Y:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:Y:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:Y:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:Y:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:Y:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:Y.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:Y:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Y:ELOSS
record(ai, "BL45P-MO-STAGE-01:Y:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:Y:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:Y:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:Y.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:Y:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:Y:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:Y:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:Y.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:Y.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:Y.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:Y.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:Y:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Y:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:Y:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:Y:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:Y:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:Y:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:Y:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:Y:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:Y:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-STAGE-01:Y, BL45P-MO-STEP-01:M7)
alias(BL45P-MO-STAGE-01:Y:ADDR, BL45P-MO-STEP-01:M7:ADDR)
alias(BL45P-MO-STAGE-01:Y:PORT, BL45P-MO-STEP-01:M7:PORT)
alias(BL45P-MO-STAGE-01:Y:SCALE, BL45P-MO-STEP-01:M7:SCALE)
alias(BL45P-MO-STAGE-01:Y:USER:SDIS, BL45P-MO-STEP-01M7:USER:SDIS)
alias(BL45P-MO-STAGE-01:Y:SDIS, BL45P-MO-STEP-01:M7:SDIS)
alias(BL45P-MO-STAGE-01:Y:KILL, BL45P-MO-STEP-01:M7:KILL)
alias(BL45P-MO-STAGE-01:Y:ELOSS, BL45P-MO-STEP-01:M7:ELOSS)
alias(BL45P-MO-STAGE-01:Y:ELOSSRC, BL45P-MO-STEP-01:M7:ELOSSRC)
alias(BL45P-MO-STAGE-01:Y:MR_MOVE_WRITE, BL45P-MO-STEP-01:M7:MR_MOVE_WRITE)
alias(BL45P-MO-STAGE-01:Y:CHECK_SYNC, BL45P-MO-STEP-01:M7:CHECK_SYNC)
alias(BL45P-MO-STAGE-01:Y:FERROR, BL45P-MO-STEP-01:M7:FERROR)
alias(BL45P-MO-STAGE-01:Y:FERRORMAX, BL45P-MO-STEP-01:M7:FERRORMAX)
alias(BL45P-MO-STAGE-01:Y:FEMAXRESET, BL45P-MO-STEP-01:M7:FEMAXRESET)
alias(BL45P-MO-STAGE-01:Y:HOMEVIS, BL45P-MO-STEP-01:M7:HOMEVIS)
alias(BL45P-MO-STAGE-01:Y:HOMEVISSTR, BL45P-MO-STEP-01:M7:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STAGE-01:Y:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STAGE-01:Y.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:Y.DIR CP")
  field(INPC, "BL45P-MO-STAGE-01:Y:SCALE")
  field(OUT, "BL45P-MO-STAGE-01:Y:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STAGE-01:Y:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+7`")
  field(FLNK, "BL45P-MO-STAGE-01:Y:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STAGE-01:Y:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STAGE-01:Y.OFF CP")
  field(OUT, "BL45P-MO-STAGE-01:Y:OFF_SET PP")
}

record(ao, "BL45P-MO-STAGE-01:Y:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+7`")
  field(FLNK, "BL45P-MO-STAGE-01:Y:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STAGE-01:Y:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,7)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STAGE-01:Y:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STAGE-01:Y:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,7)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STAGE-01:Y:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STAGE-01:Y:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,7)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STAGE-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STAGE-01:Y:SDIS") {
#  field(INPA, "BL45P-MO-STAGE-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STAGE-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STAGE-01:Y:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STAGE-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-STAGE-01:Y:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STAGE-01:Y:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STAGE-01:Y:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STAGE-01:Y:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STAGE-01:Y:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,7)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STAGE-01:Y:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#7P")
  field(DESC, "Y Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STAGE-01:Y:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STAGE-01:Y.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:Y:SCALE")
  field(INPC, "BL45P-MO-STAGE-01:Y:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STAGE-01:Y:HMPOS PP")
}

record(ai, "BL45P-MO-STAGE-01:Y:HMPOS") {
  field(DESC, "Y Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STAGE-01:Y:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STAGE-01:Y")
  field(OUT, "BL45P-MO-STAGE-01:HM:M7PV PP")
}

record(stringout, "BL45P-MO-STAGE-01:HM:M7PV"){
}

# define a kill record
record(ao, "BL45P-MO-STAGE-01:Y:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STAGE-01:Y:ELOSSVAR") {
  field(CALC, "464+7")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STAGE-01:Y:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+7`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STAGE-01:Y:ELOSSRC") {
  field(OUT, "BL45P-MO-STAGE-01:Y:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STAGE-01:Y:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+7`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS7:DESC"){
  field(VAL, "SAMP01.Y Y Stage")
}

#record(bo, "BL45P-MO-STAGE-01:Y:HOMED") {
#  field(DESC, "Set homed status for axis 7")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STAGE-01:Y:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STAGE-01:Y:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STAGE-01:Y:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m745) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STAGE-01:Y:DirectDemand")
{
    field(FLNK, "BL45P-MO-STAGE-01:Y:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STAGE-01:Y:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STAGE-01:Y:DirectDemand")
    field(INPB, "BL45P-MO-STAGE-01:Y:Mres PP")
    field(INPC, "BL45P-MO-STAGE-01:Y:Offset PP")
    field(INPD, "BL45P-MO-STAGE-01:Y:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STAGE-01:Y:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STAGE-01:Y:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STAGE-01:Y:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,7,4)MOTOR_MOVE_ABS")
    field(DESC, "Y Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STAGE-01:Y:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STAGE-01:Y:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STAGE-01:Y:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STAGE-01:Y:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STAGE-01:Y:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STAGE-01:Y:MresSource")
}

record(scalcout, BL45P-MO-STAGE-01:Y:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:Y:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STAGE-01:Y:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STAGE-01:Y:OffsetSource")
}

record(scalcout, "BL45P-MO-STAGE-01:Y:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:Y:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STAGE-01:Y:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STAGE-01:Y:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:Y:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STAGE-01:Y:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STAGE-01:Y:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:Y:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STAGE-01:Y:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M7:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M7.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M7.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M7:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M7:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M7:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+7`")
  field(FLNK, "BL45P-MO-STEP-01:M7:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M7:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M7.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M7:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M7:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+7`")
  field(FLNK, "BL45P-MO-STEP-01:M7:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M7:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,7)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M7:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M7:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,7)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M7:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M7:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,7)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M7:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M7:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M7:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M7:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M7:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M7:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M7:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,7)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M7:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#7P")
  field(DESC, "Y Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STEP-01:M7:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M7.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M7:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M7:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M7:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M7:HMPOS") {
  field(DESC, "Y Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M7:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M7")
  field(OUT, "BL45P-MO-STEP-01::HM:M7PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M7PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M7:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,7)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M7:ELOSSVAR") {
  field(CALC, "464+7")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M7:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+7`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M7:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M7:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M7:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+7`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS7:DESC"){
  field(VAL, "SAMP01.Y Y Stage")
}

#record(bo, "BL45P-MO-STEP-01:M7:HOMED") {
#  field(DESC, "Set homed status for axis 7")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M7:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M7:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M7:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m745) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M7:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M7:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M7:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M7:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M7:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M7:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M7:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M7:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M7:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M7:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,7,4)MOTOR_MOVE_ABS")
    field(DESC, "Y Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M7:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M7:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M7:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M7:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M7:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M7:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M7:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M7:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M7:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M7:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M7:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M7:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M7:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M7:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M7:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M7:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M7:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,7,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL45P-MO-STAGE-01:Z, the macros fully define the name of the motor
# (2) 'numbered' names of the form BL45P-MO-STEP-01:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Z Stage
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Z

# This associates an edm screen with the template
# % gui, SAMP01.Z, edm, motor.edl, motor=BL45P-MO-STAGE-01:Z
# % gui, SAMP01.Z, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:Z,filename=motor.edl,box-label=Z Stage

# This associates a BOY screen with the template
# % gui, SAMP01.Z, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:Z,DESC=Z Stage, name=SAMP01.Z
# % gui, SAMP01.Z, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:Z,DESC=Z Stage, name=SAMP01.Z
# % gui, SAMP01.Z, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:Z,DESC=Z Stage, name=SAMP01.Z
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.Z, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:Z

# This makes the component icon reflect the status and severity
# % gui, SAMP01.Z, status, <pv>.MOVN
# % gui, SAMP01.Z, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.Z, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.Z, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.Z, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.Z, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.Z, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.Z, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.Z, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.Z, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.Z, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.Z, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.Z, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.Z, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.Z, command, Stop,  <pv>.STOP
# % gui, SAMP01.Z, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.Z, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.Z, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.Z, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.Z, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.Z, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.Z, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.Z, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.Z, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.Z, enum, Direction,   <pv>.DIR
# % gui, SAMP01.Z, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.Z, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.Z, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.Z, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.Z, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.Z, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.Z, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.Z, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.Z, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.Z, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.Z, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.Z, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.Z, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.Z, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.Z, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.Z, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.Z, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.Z, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.Z, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.Z, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.Z, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.Z, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.Z, demand, PREC,   <pv>.PREC
# % gui, SAMP01.Z, demand, EGU,   <pv>.EGU

# % gui, SAMP01.Z, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.Z, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.Z, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.Z, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.Z, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.Z, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.Z, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.Z, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:Z")
{
	field(DESC,"Z Stage")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(BRICK1,8)")
	field(MRES,"0.0005")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"12")
	field(DLLM,"-0.05")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, "5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:Z:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:Z:ADDR") {
    field(PINI, "YES")
    field(VAL, "8")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:Z:PORT") {
    field(PINI, "YES")
    field(VAL, "BRICK1")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:Z:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:Z:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:Z:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:Z:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:Z:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:Z.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:Z:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Z:ELOSS
record(ai, "BL45P-MO-STAGE-01:Z:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:Z:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:Z:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:Z.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:Z:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:Z:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:Z:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:Z.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:Z.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:Z.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:Z.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:Z:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:Z:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:Z:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:Z:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:Z:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:Z:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:Z:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:Z:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:Z:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL45P-MO-STAGE-01:Z, BL45P-MO-STEP-01:M8)
alias(BL45P-MO-STAGE-01:Z:ADDR, BL45P-MO-STEP-01:M8:ADDR)
alias(BL45P-MO-STAGE-01:Z:PORT, BL45P-MO-STEP-01:M8:PORT)
alias(BL45P-MO-STAGE-01:Z:SCALE, BL45P-MO-STEP-01:M8:SCALE)
alias(BL45P-MO-STAGE-01:Z:USER:SDIS, BL45P-MO-STEP-01M8:USER:SDIS)
alias(BL45P-MO-STAGE-01:Z:SDIS, BL45P-MO-STEP-01:M8:SDIS)
alias(BL45P-MO-STAGE-01:Z:KILL, BL45P-MO-STEP-01:M8:KILL)
alias(BL45P-MO-STAGE-01:Z:ELOSS, BL45P-MO-STEP-01:M8:ELOSS)
alias(BL45P-MO-STAGE-01:Z:ELOSSRC, BL45P-MO-STEP-01:M8:ELOSSRC)
alias(BL45P-MO-STAGE-01:Z:MR_MOVE_WRITE, BL45P-MO-STEP-01:M8:MR_MOVE_WRITE)
alias(BL45P-MO-STAGE-01:Z:CHECK_SYNC, BL45P-MO-STEP-01:M8:CHECK_SYNC)
alias(BL45P-MO-STAGE-01:Z:FERROR, BL45P-MO-STEP-01:M8:FERROR)
alias(BL45P-MO-STAGE-01:Z:FERRORMAX, BL45P-MO-STEP-01:M8:FERRORMAX)
alias(BL45P-MO-STAGE-01:Z:FEMAXRESET, BL45P-MO-STEP-01:M8:FEMAXRESET)
alias(BL45P-MO-STAGE-01:Z:HOMEVIS, BL45P-MO-STEP-01:M8:HOMEVIS)
alias(BL45P-MO-STAGE-01:Z:HOMEVISSTR, BL45P-MO-STEP-01:M8:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STAGE-01:Z:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STAGE-01:Z.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:Z.DIR CP")
  field(INPC, "BL45P-MO-STAGE-01:Z:SCALE")
  field(OUT, "BL45P-MO-STAGE-01:Z:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STAGE-01:Z:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+8`")
  field(FLNK, "BL45P-MO-STAGE-01:Z:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STAGE-01:Z:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STAGE-01:Z.OFF CP")
  field(OUT, "BL45P-MO-STAGE-01:Z:OFF_SET PP")
}

record(ao, "BL45P-MO-STAGE-01:Z:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+8`")
  field(FLNK, "BL45P-MO-STAGE-01:Z:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STAGE-01:Z:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,8)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STAGE-01:Z:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STAGE-01:Z:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,8)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STAGE-01:Z:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STAGE-01:Z:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,8)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STAGE-01. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STAGE-01:Z:SDIS") {
#  field(INPA, "BL45P-MO-STAGE-01:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STAGE-01:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STAGE-01:Z:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STAGE-01:HM:HOMING CP")
  field(FLNK, "BL45P-MO-STAGE-01:Z:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STAGE-01:Z:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STAGE-01:Z:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STAGE-01:Z:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STAGE-01:Z:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,8)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STAGE-01:Z:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#8P")
  field(DESC, "Z Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STAGE-01:Z:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STAGE-01:Z.MRES CP")
  field(INPB, "BL45P-MO-STAGE-01:Z:SCALE")
  field(INPC, "BL45P-MO-STAGE-01:Z:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STAGE-01:Z:HMPOS PP")
}

record(ai, "BL45P-MO-STAGE-01:Z:HMPOS") {
  field(DESC, "Z Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STAGE-01:Z:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STAGE-01:Z")
  field(OUT, "BL45P-MO-STAGE-01:HM:M8PV PP")
}

record(stringout, "BL45P-MO-STAGE-01:HM:M8PV"){
}

# define a kill record
record(ao, "BL45P-MO-STAGE-01:Z:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STAGE-01:Z:ELOSSVAR") {
  field(CALC, "464+8")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STAGE-01:Z:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+8`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STAGE-01:Z:ELOSSRC") {
  field(OUT, "BL45P-MO-STAGE-01:Z:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STAGE-01:Z:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+8`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS8:DESC"){
  field(VAL, "SAMP01.Z Z Stage")
}

#record(bo, "BL45P-MO-STAGE-01:Z:HOMED") {
#  field(DESC, "Set homed status for axis 8")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STAGE-01:Z:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STAGE-01:Z:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STAGE-01:Z:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m845) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STAGE-01:Z:DirectDemand")
{
    field(FLNK, "BL45P-MO-STAGE-01:Z:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STAGE-01:Z:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STAGE-01:Z:DirectDemand")
    field(INPB, "BL45P-MO-STAGE-01:Z:Mres PP")
    field(INPC, "BL45P-MO-STAGE-01:Z:Offset PP")
    field(INPD, "BL45P-MO-STAGE-01:Z:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STAGE-01:Z:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STAGE-01:Z:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STAGE-01:Z:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,8,4)MOTOR_MOVE_ABS")
    field(DESC, "Z Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STAGE-01:Z:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STAGE-01:Z:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STAGE-01:Z:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STAGE-01:Z:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STAGE-01:Z:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STAGE-01:Z:MresSource")
}

record(scalcout, BL45P-MO-STAGE-01:Z:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:Z:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STAGE-01:Z:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STAGE-01:Z:OffsetSource")
}

record(scalcout, "BL45P-MO-STAGE-01:Z:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:Z:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STAGE-01:Z:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STAGE-01:Z:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STAGE-01:Z:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STAGE-01:Z:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STAGE-01:Z:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STAGE-01:Z:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STAGE-01:Z:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL45P-MO-STEP-01:M8:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL45P-MO-STEP-01:M8.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M8.DIR CP")
  field(INPC, "BL45P-MO-STEP-01:M8:SCALE")
  field(OUT, "BL45P-MO-STEP-01:M8:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL45P-MO-STEP-01:M8:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4800+8`")
  field(FLNK, "BL45P-MO-STEP-01:M8:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL45P-MO-STEP-01:M8:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL45P-MO-STEP-01:M8.OFF CP")
  field(OUT, "BL45P-MO-STEP-01:M8:OFF_SET PP")
}

record(ao, "BL45P-MO-STEP-01:M8:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PMAC_WD_P`4900+8`")
  field(FLNK, "BL45P-MO-STEP-01:M8:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL45P-MO-STEP-01:M8:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(BRICK1,8)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL45P-MO-STEP-01:M8:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL45P-MO-STEP-01:M8:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,8)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL45P-MO-STEP-01:M8:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL45P-MO-STEP-01:M8:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(BRICK1,8)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL45P-MO-STEP-01:. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL45P-MO-STEP-01:M8:SDIS") {
#  field(INPA, "BL45P-MO-STEP-01::HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL45P-MO-STEP-01::HM:HOMING") {
}

# Monitor homing status
record(bi, "BL45P-MO-STEP-01:M8:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL45P-MO-STEP-01::HM:HOMING CP")
  field(FLNK, "BL45P-MO-STEP-01:M8:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL45P-MO-STEP-01:M8:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL45P-MO-STEP-01:M8:HOMING")
    field(CALC, "A")
    field(OUT, "BL45P-MO-STEP-01:M8:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL45P-MO-STEP-01:M8:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(BRICK1,8)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL45P-MO-STEP-01:M8:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_VDF_#8P")
  field(DESC, "Z Stage")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL45P-MO-STEP-01:M8:HMPOS:CALC") {
  field(INPA, "BL45P-MO-STEP-01:M8.MRES CP")
  field(INPB, "BL45P-MO-STEP-01:M8:SCALE")
  field(INPC, "BL45P-MO-STEP-01:M8:HMPOS_RBV CP")
  field(CALC, "A*B*C")
  field(OUT, "BL45P-MO-STEP-01:M8:HMPOS PP")
}

record(ai, "BL45P-MO-STEP-01:M8:HMPOS") {
  field(DESC, "Z Stage")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL45P-MO-STEP-01:M8:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL45P-MO-STEP-01:M8")
  field(OUT, "BL45P-MO-STEP-01::HM:M8PV PP")
}

record(stringout, "BL45P-MO-STEP-01::HM:M8PV"){
}

# define a kill record
record(ao, "BL45P-MO-STEP-01:M8:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,8)PMAC_C_KILL_AXIS")
  field(VAL, "0")
}

record(calc, "BL45P-MO-STEP-01:M8:ELOSSVAR") {
  field(CALC, "464+8")
  field(PINI, "YES")
}

record(ai, "BL45P-MO-STEP-01:M8:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_VIS_P`464+8`")
  field(SCAN, "I/O Intr")
}

record(calcout, "BL45P-MO-STEP-01:M8:ELOSSRC") {
  field(OUT, "BL45P-MO-STEP-01:M8:SEND_ELOSSRC PP")
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")
}

record(ao, "BL45P-MO-STEP-01:M8:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_VIS_P`464+8`")
}

# Overwrite the description of pmacStatus
record(stringout, "BL45P-MO-STEP-01:AXIS8:DESC"){
  field(VAL, "SAMP01.Z Z Stage")
}

#record(bo, "BL45P-MO-STEP-01:M8:HOMED") {
#  field(DESC, "Set homed status for axis 8")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL45P-MO-STEP-01:M8:HOMEDSET")
#}

#record(calcout, "BL45P-MO-STEP-01:M8:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL45P-MO-STEP-01:M8:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m845) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:M8:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:M8:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:M8:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:M8:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:M8:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:M8:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:M8:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:M8:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:M8:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:M8:DirectMotorSeq")
    field(OUT,  "@asyn(BRICK1,8,4)MOTOR_MOVE_ABS")
    field(DESC, "Z Stage")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:M8:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:M8:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:M8:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(BRICK1,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:M8:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:M8:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(BRICK1,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:M8:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:M8:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:M8:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:M8:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:M8:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M8:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:M8:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:M8:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:M8:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:M8:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:M8:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:M8:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(BRICK1,8,4)PMAC_OFFSET")
}##############################################################
#
# Records to read asynPortDriver parameters from the param
# library for the class pmacCsController.
#
# The Asyn address is set as zero because that's what we use
# for controller parameters.
#
##############################################################

# % macro, PORT, The asyn port for the pmac cs controller
# % macro, PARENTPORT, The asyn port for the parent pmac controller
# % macro, TIMEOUT, Timeout for controller communication
# % macro, PMAC, PV Prefix for the motor controller
# % macro, CS, Coordinate System Number for the cs controller

#
# allow query of this CS controller's Parent's Port Name
#
record(stringout, "BL45P-MO-STEP-01:CS1:ParentPort")
{
    field(VAL, "BRICK1")
    field(PINI, "YES")
}

#
# allow query of this CS controller's Port Name
#
record(stringout, "BL45P-MO-STEP-01:CS1:Port")
{
    field(VAL, "CS1")
    field(PINI, "YES")
}

#
# abort motion in this CS
#
record(bo, "BL45P-MO-STEP-01:CS1:Abort")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,0,4)PMAC_C_ABORT")
}

##############################################################
# Control deferred mode for all axes in this CS
##############################################################
record(bo, "BL45P-MO-STEP-01:CS1:DeferMoves")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,0,4)MOTOR_DEFER_MOVES")
    field(VAL, "0")
    field(ZNAM, "Defer Off")
    field(ONAM, "Defer On")
}


##############################################################
# Control the time of programmed moves
# 0 = fast as possible
# -1 = controlled by CS default feedrate isx89
# >0 = take at least this many milli-secs to move
##############################################################
# % autosave 2
record(ao, "BL45P-MO-STEP-01:CS1:CsMoveTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,0,4)PMAC_C_CS_MOVE_TIME")
    field(VAL, "-1")
}

record(ai, "BL45P-MO-STEP-01:CS1:CsMoveTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(CS1,0,4)PMAC_C_CS_MOVE_TIME")
    field(SCAN, "I/O Intr")
}

##############################################################
# Record of the Kinematics on the PMAC
##############################################################

record(waveform, "BL45P-MO-STEP-01:CS1:FWD_KINEMATIC_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS1,0)PMAC_CS_FWD_KIN")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:CS1:INV_KINEMATIC_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS1,0)PMAC_CS_INV_KIN")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

##############################################################
# Listing of combined Q Variables (slow poll)
##############################################################
record(waveform, "BL45P-MO-STEP-01:CS1:Q_VARIABLES_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS1,0)PMAC_CS_Q_VARIABLES")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

##############################################################
# Immediate demands for each CS motor
##############################################################
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M1:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M1:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M1:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M1:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M1:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M1:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M1:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M1:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M1:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M1:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,1,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor A")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M1:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M1:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M1:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,1,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M1:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,1,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M1:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,1,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M1:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M1:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M1:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M1:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M1:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M1:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M1:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,1,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M1:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M1:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M1:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M1:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M1:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,1,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M2:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M2:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M2:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M2:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M2:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M2:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M2:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M2:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M2:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M2:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,2,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor B")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M2:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M2:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M2:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,2,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M2:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,2,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M2:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,2,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M2:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M2:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M2:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M2:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M2:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M2:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M2:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,2,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M2:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M2:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M2:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M2:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M2:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,2,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M3:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M3:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M3:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M3:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M3:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M3:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M3:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M3:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M3:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M3:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,3,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor C")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M3:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M3:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M3:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M3:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M3:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M3:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M3:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M3:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M3:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M3:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M3:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M3:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M3:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M3:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M3:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M3:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M3:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,3,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M4:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M4:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M4:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M4:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M4:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M4:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M4:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M4:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M4:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M4:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,4,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor U")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M4:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M4:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M4:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M4:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M4:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M4:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M4:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M4:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M4:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M4:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M4:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M4:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M4:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M4:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M4:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M4:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M4:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,4,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M5:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M5:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M5:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M5:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M5:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M5:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M5:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M5:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M5:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M5:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,5,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor V")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M5:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M5:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M5:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M5:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M5:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M5:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M5:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M5:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M5:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M5:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M5:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M5:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M5:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M5:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M5:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M5:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M5:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,5,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M6:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M6:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M6:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M6:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M6:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M6:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M6:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M6:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M6:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M6:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,6,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor W")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M6:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M6:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M6:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M6:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M6:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M6:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M6:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M6:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M6:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M6:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M6:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M6:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M6:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M6:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M6:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M6:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M6:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,6,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M7:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M7:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M7:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M7:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M7:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M7:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M7:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M7:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M7:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M7:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,7,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor X")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M7:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M7:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M7:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M7:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M7:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M7:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M7:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M7:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M7:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M7:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M7:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M7:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M7:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M7:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M7:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M7:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M7:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,7,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M8:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M8:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M8:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M8:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M8:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M8:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M8:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M8:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M8:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M8:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,8,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor Y")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M8:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M8:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M8:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M8:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M8:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M8:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M8:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M8:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M8:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M8:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M8:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M8:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M8:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M8:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M8:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M8:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M8:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,8,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS1:M9:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS1:M9:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M9:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS1:M9:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS1:M9:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS1:M9:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS1:M9:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS1:M9:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS1:M9:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M9:DirectMotorSeq")
    field(OUT,  "@asyn(CS1,9,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor Z")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS1:M9:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS1:M9:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS1:M9:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS1,9,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS1:M9:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS1,9,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS1:M9:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS1,9,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M9:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS1:M9:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M9:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS1:M9:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS1:M9:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS1:M9:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M9:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS1:M9:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,9,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS1:M9:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS1:M9:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS1:M9:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS1:M9:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS1:M9:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS1:M9:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS1,9,4)PMAC_OFFSET")
}##############################################################
#
# Records to read asynPortDriver parameters from the param
# library for the class pmacCsController.
#
# The Asyn address is set as zero because that's what we use
# for controller parameters.
#
##############################################################

# % macro, PORT, The asyn port for the pmac cs controller
# % macro, PARENTPORT, The asyn port for the parent pmac controller
# % macro, TIMEOUT, Timeout for controller communication
# % macro, PMAC, PV Prefix for the motor controller
# % macro, CS, Coordinate System Number for the cs controller

#
# allow query of this CS controller's Parent's Port Name
#
record(stringout, "BL45P-MO-STEP-01:CS2:ParentPort")
{
    field(VAL, "BRICK1")
    field(PINI, "YES")
}

#
# allow query of this CS controller's Port Name
#
record(stringout, "BL45P-MO-STEP-01:CS2:Port")
{
    field(VAL, "CS2")
    field(PINI, "YES")
}

#
# abort motion in this CS
#
record(bo, "BL45P-MO-STEP-01:CS2:Abort")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,0,4)PMAC_C_ABORT")
}

##############################################################
# Control deferred mode for all axes in this CS
##############################################################
record(bo, "BL45P-MO-STEP-01:CS2:DeferMoves")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,0,4)MOTOR_DEFER_MOVES")
    field(VAL, "0")
    field(ZNAM, "Defer Off")
    field(ONAM, "Defer On")
}


##############################################################
# Control the time of programmed moves
# 0 = fast as possible
# -1 = controlled by CS default feedrate isx89
# >0 = take at least this many milli-secs to move
##############################################################
# % autosave 2
record(ao, "BL45P-MO-STEP-01:CS2:CsMoveTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,0,4)PMAC_C_CS_MOVE_TIME")
    field(VAL, "-1")
}

record(ai, "BL45P-MO-STEP-01:CS2:CsMoveTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(CS2,0,4)PMAC_C_CS_MOVE_TIME")
    field(SCAN, "I/O Intr")
}

##############################################################
# Record of the Kinematics on the PMAC
##############################################################

record(waveform, "BL45P-MO-STEP-01:CS2:FWD_KINEMATIC_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS2,0)PMAC_CS_FWD_KIN")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:CS2:INV_KINEMATIC_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS2,0)PMAC_CS_INV_KIN")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

##############################################################
# Listing of combined Q Variables (slow poll)
##############################################################
record(waveform, "BL45P-MO-STEP-01:CS2:Q_VARIABLES_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(CS2,0)PMAC_CS_Q_VARIABLES")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

##############################################################
# Immediate demands for each CS motor
##############################################################
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M1:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M1:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M1:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M1:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M1:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M1:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M1:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M1:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M1:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M1:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,1,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor A")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M1:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M1:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M1:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,1,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M1:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,1,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M1:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,1,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M1:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M1:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M1:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M1:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M1:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M1:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M1:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,1,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M1:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M1:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M1:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M1:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M1:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,1,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M2:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M2:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M2:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M2:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M2:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M2:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M2:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M2:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M2:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M2:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,2,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor B")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M2:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M2:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M2:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,2,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M2:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,2,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M2:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,2,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M2:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M2:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M2:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M2:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M2:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M2:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M2:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,2,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M2:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M2:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M2:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M2:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M2:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,2,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M3:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M3:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M3:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M3:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M3:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M3:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M3:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M3:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M3:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M3:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,3,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor C")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M3:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M3:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M3:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M3:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M3:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M3:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M3:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M3:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M3:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M3:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M3:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M3:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M3:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M3:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M3:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M3:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M3:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,3,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M4:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M4:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M4:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M4:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M4:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M4:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M4:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M4:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M4:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M4:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,4,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor U")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M4:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M4:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M4:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M4:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M4:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M4:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M4:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M4:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M4:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M4:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M4:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M4:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M4:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M4:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M4:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M4:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M4:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,4,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M5:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M5:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M5:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M5:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M5:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M5:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M5:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M5:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M5:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M5:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,5,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor V")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M5:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M5:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M5:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M5:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M5:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M5:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M5:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M5:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M5:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M5:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M5:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M5:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M5:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M5:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M5:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M5:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M5:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,5,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M6:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M6:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M6:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M6:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M6:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M6:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M6:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M6:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M6:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M6:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,6,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor W")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M6:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M6:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M6:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M6:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M6:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M6:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M6:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M6:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M6:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M6:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M6:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M6:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M6:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M6:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M6:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M6:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M6:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,6,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M7:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M7:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M7:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M7:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M7:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M7:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M7:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M7:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M7:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M7:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,7,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor X")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M7:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M7:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M7:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M7:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M7:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M7:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M7:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M7:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M7:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M7:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M7:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M7:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M7:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M7:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M7:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M7:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M7:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,7,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M8:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M8:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M8:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M8:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M8:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M8:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M8:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M8:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M8:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M8:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,8,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor Y")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M8:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M8:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M8:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M8:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M8:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M8:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M8:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M8:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M8:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M8:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M8:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M8:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M8:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M8:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M8:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M8:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M8:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,8,4)PMAC_OFFSET")
}##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL45P-MO-STEP-01:CS2:M9:DirectDemand")
{
    field(FLNK, "BL45P-MO-STEP-01:CS2:M9:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M9:DirectCountsCalc")
{
    field(INPA, "BL45P-MO-STEP-01:CS2:M9:DirectDemand")
    field(INPB, "BL45P-MO-STEP-01:CS2:M9:Mres PP")
    field(INPC, "BL45P-MO-STEP-01:CS2:M9:Offset PP")
    field(INPD, "BL45P-MO-STEP-01:CS2:M9:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL45P-MO-STEP-01:CS2:M9:RawDirectDemand PP")
}

record(ao, "BL45P-MO-STEP-01:CS2:M9:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M9:DirectMotorSeq")
    field(OUT,  "@asyn(CS2,9,4)MOTOR_MOVE_ABS")
    field(DESC, "CS Motor Z")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL45P-MO-STEP-01:CS2:M9:DirectMotorSeq")
{
    field(LNK1, "BL45P-MO-STEP-01:CS2:M9:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL45P-MO-STEP-01:CS2:M9:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(CS2,9,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL45P-MO-STEP-01:CS2:M9:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(CS2,9,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL45P-MO-STEP-01:CS2:M9:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(CS2,9,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M9:MresSource")
}

record(scalcout, BL45P-MO-STEP-01:CS2:M9:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M9:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.MRES CPP',A)):1")
    field(OUT, "BL45P-MO-STEP-01:CS2:M9:Mres.INPA CA")
    field(FLNK, "BL45P-MO-STEP-01:CS2:M9:OffsetSource")
}

record(scalcout, "BL45P-MO-STEP-01:CS2:M9:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M9:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL45P-MO-STEP-01:CS2:M9:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,9,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL45P-MO-STEP-01:CS2:M9:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL45P-MO-STEP-01:CS2:M9:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BL45P-MO-STEP-01:M%d.OFF CPP',A)):0")
    field(OUT, "BL45P-MO-STEP-01:CS2:M9:Offset.INPA CA")
}


record(scalcout, BL45P-MO-STEP-01:CS2:M9:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL45P-MO-STEP-01:CS2:M9:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL45P-MO-STEP-01:CS2:M9:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(CS2,9,4)PMAC_OFFSET")
}# % macro, PORT, The asyn port for the pmac controller
# % macro, PMAC, PV Prefix for the motor controller
# % macro, NPOINTS, Number of points that can be built at any time
# % macro, MAXPOINTS, Maximum number of points in a scan
# % macro, NAxes,   Number of axes
# % macro, PREC, precision of axis defnitions


#
# allow query of parent's Port Name
#
record(stringout, "BL45P-MO-STEP-01:ParentPort")
{
    field(VAL, "BRICK1")
    field(PINI, "YES")
}

##
## Records to read the motion program and driver versions
##
record(ai, "BL45P-MO-STEP-01:ProgramVersion_RBV") {
  field(DESC, "Motion Program Version")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_PROG_V")
  field(SCAN, "I/O Intr")
}

record(ai, "BL45P-MO-STEP-01:DriverVersion_RBV") {
  field(DESC, "EPICS Driver Version")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_CODE_V")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:ProfileNaxes") {
  field(PINI, "YES")
  field(VAL, "8")
}

##
## Record to read the number of axes selected for the current
## trajectory scan
##
record(longin, "BL45P-MO-STEP-01:ProfileNumAxes_RBV") {
  field(DESC, "Number of axes selected")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_NUM_AXES")
  field(SCAN, "I/O Intr")
}

record(longout,"BL45P-MO-STEP-01:ProfileNumPoints") {
    field(DESC, "# of points in profile")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_NUM_POINTS")
    field(VAL,  "4000000")
}

##
## Records to specify the number of motion points that define
## the trajectory scan
##
record(longin, "BL45P-MO-STEP-01:ProfileNumPoints_RBV") {
  field(DESC, "Number of points defined")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_NUM_POINTS")
  field(SCAN, "I/O Intr")
}


##
## Records to specify the number of motion points to build
## into the scan currently
##
record(longout,"BL45P-MO-STEP-01:ProfilePointsToBuild") {
    field(DESC, "# of points to build/append")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_NUM_BUILD")
    field(VAL,  "0")
}

record(longin, "BL45P-MO-STEP-01:ProfilePointsToBuild_RBV") {
  field(DESC, "# of points to build/append")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_NUM_BUILD")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:ProfilePointsBuilt_RBV") {
  field(DESC, "# of points built into scan")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_POINTS_BUILT")
  field(SCAN, "I/O Intr")
}

##
## Record to read the current executing point of trajectory scan
##
record(longin, "BL45P-MO-STEP-01:ProfileCurrentPoint_RBV") {
  field(DESC, "Currently executing point")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_CURRENT_POINT")
  field(SCAN, "I/O Intr")
}


##
## Records to set the current time mode for the trajectory scan
## FIXED => A single value is used for each point
## ARRAY => An array of time points is supplied
##
record(bo, "BL45P-MO-STEP-01:ProfileTimeMode")
{
  field(DESC, "Time mode for trajectory scan")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn(BRICK1,0)PROFILE_TIME_MODE")
  field(ZNAM, "FIXED")
  field(ONAM, "ARRAY")
  field(VAL,  "1")
  field(PINI, "YES")
}

record(bi, "BL45P-MO-STEP-01:ProfileTimeMode_RBV")
{
  field(DESC, "Time mode for trajectory scan")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn(BRICK1,0)PROFILE_TIME_MODE")
  field(ZNAM, "FIXED")
  field(ONAM, "ARRAY")
  field(SCAN, "I/O Intr")
}

##
## Records to specify the fixed time between points
##
record(ao, "BL45P-MO-STEP-01:ProfileFixedTime") {
  field(DESC, "Fixed time between points")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(BRICK1,0)PROFILE_FIXED_TIME")
  field(PINI, "NO")
}

record(ai, "BL45P-MO-STEP-01:ProfileFixedTime_RBV") {
  field(DESC, "Fixed time between points")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PROFILE_FIXED_TIME")
  field(SCAN, "I/O Intr")
}

##
## Record to specify the array of times between points
##
record(waveform, "BL45P-MO-STEP-01:ProfileTimeArray")
{
    field(PINI, "NO")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_TIME_ARRAY")
    field(FTVL, "DOUBLE")
    field(NELM, "500000")
}

## Record to specify the User profile called at each point
record(waveform,"BL45P-MO-STEP-01:UserArray") {
    field(DESC, "User profile call at each point")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PMAC_PROFILE_USER")
    field(NELM, "500000")
    field(FTVL, "LONG")
    field(PREC, "3")
}

## Record to specific the Velocity mode to use at each point
record(waveform,"BL45P-MO-STEP-01:VelocityMode") {
    field(DESC, "Velocity mode at each point")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PMAC_PROFILE_VELMODE")
    field(NELM, "500000")
    field(FTVL, "LONG")
    field(PREC, "3")
}


###################################################################
#  These records control trajectory scan building (pre-execute)   #
#                                                                 #
###################################################################

#record(stringout, "BL45P-MO-STEP-01:ProfileCsName") {
#  field(DTYP, "asynOctetWrite")
#  field(OUT, "@asyn(BRICK1,0)PMAC_C_TRAJ_CS_PORT")
#}

record(mbbo, "BL45P-MO-STEP-01:ProfileCsName")
{
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn(BRICK1 0)PMAC_C_TRAJ_CS_PORT")
  field(PINI, "YES")
  field(VAL,  "0")
}

#record(stringin, "BL45P-MO-STEP-01:ProfileCsName_RBV") {
#  field(DTYP, "asynOctetRead")
#  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_CS_PORT")
#  field(SCAN, "I/O Intr")
#}

record(mbbi, "BL45P-MO-STEP-01:ProfileCsName_RBV")
{
  field(DTYP, "asynInt32")
  field(INP,  "@asyn(BRICK1 0)PMAC_C_TRAJ_CS_PORT")
  field(SCAN, "I/O Intr")
  field(VAL,  "0")
}

###################################################################
#  These records control trajectory scan building (pre-execute)   #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:ProfileBuild") {
    field(DESC,"Build and check profile")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_BUILD")
    field(ZNAM, "Done")
    field(ONAM, "Build")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileBuildState_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_BUILD_STATE")
  field(ZRVL, "0")
  field(ZRST, "Done")
  field(ZRSV, "NO_ALARM")
  field(ONVL, "1")
  field(ONST, "Busy")
  field(ONSV, "MINOR")
  field(SCAN, "I/O Intr")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileBuildStatus_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_BUILD_STATUS")
  field(ZRVL, "0")
  field(ZRST, "Undefined")
  field(ZRSV, "INVALID")
  field(ONVL, "1")
  field(ONST, "Success")
  field(ONSV, "NO_ALARM")
  field(TWVL, "2")
  field(TWST, "Failure")
  field(TWSV, "MAJOR")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:ProfileBuildMessage_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PROFILE_BUILD_MESSAGE")
  field(FTVL, "CHAR")
  field(NELM, "1000")
  field(SCAN, "I/O Intr")
}


###################################################################
#  These records control trajectory scan appending (points can    #
#  only be appended after a scan has been built)                  #
###################################################################

record(bo,"BL45P-MO-STEP-01:ProfileAppend") {
    field(DESC,"Append points to profile")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_APPEND")
    field(ZNAM, "Done")
    field(ONAM, "Append")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileAppendState_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_APPEND_STATE")
  field(ZRVL, "0")
  field(ZRST, "Done")
  field(ZRSV, "NO_ALARM")
  field(ONVL, "1")
  field(ONST, "Busy")
  field(ONSV, "MINOR")
  field(SCAN, "I/O Intr")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileAppendStatus_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_APPEND_STATUS")
  field(ZRVL, "0")
  field(ZRST, "Undefined")
  field(ZRSV, "INVALID")
  field(ONVL, "1")
  field(ONST, "Success")
  field(ONSV, "NO_ALARM")
  field(TWVL, "2")
  field(TWST, "Failure")
  field(TWSV, "MAJOR")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:ProfileAppendMessage_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PROFILE_APPEND_MESSAGE")
  field(FTVL, "CHAR")
  field(NELM, "1000")
  field(SCAN, "I/O Intr")
}


###################################################################
#  These records control trajectory scan execution                #
#                                                                 #
###################################################################

record(busy,"BL45P-MO-STEP-01:ProfileExecute") {
    field(DESC,"Execute the profile")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_EXECUTE")
    field(ZNAM, "Done")
    field(ONAM, "Execute")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileExecuteState_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_EXECUTE_STATE")
  field(ZRVL, "0")
  field(ZRST, "Done")
  field(ZRSV, "NO_ALARM")
  field(ONVL, "1")
  field(ONST, "Move start")
  field(ONSV, "MINOR")
  field(TWVL, "2")
  field(TWST, "Executing")
  field(TWSV, "MINOR")
  field(THVL, "3")
  field(THST, "Flyback")
  field(THSV, "MINOR")
  field(SCAN, "I/O Intr")
}

record(mbbi, "BL45P-MO-STEP-01:ProfileExecuteStatus_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PROFILE_EXECUTE_STATUS")
  field(ZRVL, "0")
  field(ZRST, "Undefined")
  field(ZRSV, "INVALID")
  field(ONVL, "1")
  field(ONST, "Success")
  field(ONSV, "NO_ALARM")
  field(TWVL, "2")
  field(TWST, "Failure")
  field(TWSV, "MAJOR")
  field(THVL, "3")
  field(THST, "Abort")
  field(THSV, "MAJOR")
  field(FRVL, "4")
  field(FRST, "Timeout")
  field(FRSV, "MAJOR")
  field(SCAN, "I/O Intr")
}

record(waveform, "BL45P-MO-STEP-01:ProfileExecuteMessage_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(BRICK1,0)PROFILE_EXECUTE_MESSAGE")
  field(FTVL, "CHAR")
  field(NELM, "1000")
  field(SCAN, "I/O Intr")
}

###################################################################
#  This record aborts a trajectory scan                           #
#                                                                 #
###################################################################

record(busy,"BL45P-MO-STEP-01:ProfileAbort") {
    field(DESC,"Abort currently executing profile")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_ABORT")
    field(ZNAM, "Done")
    field(ONAM, "Abort")
}

###################################################################
#  These records are to set and read the motion program number    #
#                                                                 #
###################################################################

record(longout, "BL45P-MO-STEP-01:TscanProgNo") {
  field(DESC, "Trajectory program number")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(BRICK1,0)PMAC_C_TRAJ_PROG")
}

record(longin, "BL45P-MO-STEP-01:TscanProgNo_RBV") {
  field(DESC, "Trajectory program number")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_PROG")
  field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide status feedback                          #
#                                                                 #
###################################################################

record(longin, "BL45P-MO-STEP-01:BufferAAddress_RBV") {
  field(DESC, "PMAC address of buffer A")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_ADRA")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:BufferBAddress_RBV") {
  field(DESC, "PMAC address of buffer B")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_ADRB")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:BufferLength_RBV") {
  field(DESC, "Length of trajectory buffers")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_LENGTH")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:CurrentIndex_RBV") {
  field(DESC, "Current PMAC index of buffer")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_INDEX")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:TotalPoints_RBV") {
  field(DESC, "Total points scanned")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_POINTS")
  field(SCAN, "I/O Intr")
}

record(bi, "BL45P-MO-STEP-01:CurrentBuffer_RBV") {
  field(DESC, "Current PMAC buffer in use")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_CBUFF")
  field(ZNAM, "A")
  field(ONAM, "B")
  field(SCAN, "I/O Intr")
}

record(mbbi, "BL45P-MO-STEP-01:TrajectoryStatus_RBV") {
  field(DESC, "Current PMAC trajectory status")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_STATUS")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(ZRST, "Idle")
  field(ONST, "Running")
  field(TWST, "Finished")
  field(THST, "Error")
  field(SCAN, "I/O Intr")
}

###################################################################
#  These records report the current EPICS filled buffer ptrs      #
#                                                                 #
###################################################################

record(longin, "BL45P-MO-STEP-01:EpicsBufferAPtr_RBV") {
  field(DESC, "Current EPICS buffer A Ptr")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_FILLA")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:EpicsBufferBPtr_RBV") {
  field(DESC, "Current EPICS buffer B Ptr")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_FILLB")
  field(SCAN, "I/O Intr")
}

record(ai, "BL45P-MO-STEP-01:TscanTime_RBV") {
  field(DESC, "Time of scan (s)")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BL45P-MO-STEP-01:TscanCs_RBV") {
  field(DESC, "CS Number of current scan")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_CS")
  field(SCAN, "I/O Intr")
}

record(ai, "BL45P-MO-STEP-01:TscanPercent_RBV") {
  field(DESC, "Time of scan (s)")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_PERCENT")
  field(SCAN, "I/O Intr")
  field(EGU, "%")
}

record(mbbi, "BL45P-MO-STEP-01:TscanExtStatus_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(BRICK1,0)PMAC_C_TRAJ_ESTATUS")
  field(ZRVL, "0")
  field(ZRST, "Good")
  field(ZRSV, "NO_ALARM")
  field(ONVL, "1")
  field(ONST, "Bad")
  field(ONSV, "MAJOR")
  field(SCAN, "I/O Intr")
}

###################################################################
#  Axis A Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:A:UseAxis") {
    field(DESC, "Use axis A in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_A")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:A:Positions") {
    field(DESC, "Axis A positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_A")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:A:NoOfPts") {
    field(DESC, "Axis A Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:A:Positions.NORD")
}

###################################################################
#  Axis B Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:B:UseAxis") {
    field(DESC, "Use axis B in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_B")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:B:Positions") {
    field(DESC, "Axis B positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_B")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:B:NoOfPts") {
    field(DESC, "Axis B Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:B:Positions.NORD")
}


###################################################################
#  Axis C Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:C:UseAxis") {
    field(DESC, "Use axis C in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_C")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:C:Positions") {
    field(DESC, "Axis C positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_C")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:C:NoOfPts") {
    field(DESC, "Axis C Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:C:Positions.NORD")
}


###################################################################
#  Axis U Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:U:UseAxis") {
    field(DESC, "Use axis U in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_U")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:U:Positions") {
    field(DESC, "Axis U positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_U")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:U:NoOfPts") {
    field(DESC, "Axis U Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:U:Positions.NORD")
}


###################################################################
#  Axis V Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:V:UseAxis") {
    field(DESC, "Use axis V in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_V")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:V:Positions") {
    field(DESC, "Axis V positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_V")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:V:NoOfPts") {
    field(DESC, "Axis V Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:V:Positions.NORD")
}

###################################################################
#  Axis W Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:W:UseAxis") {
    field(DESC, "Use axis W in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_W")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:W:Positions") {
    field(DESC, "Axis W positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_W")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:W:NoOfPts") {
    field(DESC, "Axis W Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:W:Positions.NORD")
}

###################################################################
#  Axis X Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:X:UseAxis") {
    field(DESC, "Use axis X in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_X")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:X:Positions") {
    field(DESC, "Axis X positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_X")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:X:NoOfPts") {
    field(DESC, "Axis X Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:X:Positions.NORD")
}

###################################################################
#  Axis Y Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:Y:UseAxis") {
    field(DESC, "Use axis Y in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_Y")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:Y:Positions") {
    field(DESC, "Axis Y positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_Y")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:Y:NoOfPts") {
    field(DESC, "Axis Y Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:Y:Positions.NORD")
}

###################################################################
#  Axis Z Trajectory Scan Records                                 #
#                                                                 #
###################################################################

record(bo,"BL45P-MO-STEP-01:Z:UseAxis") {
    field(DESC, "Use axis Z in scan")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(BRICK1,0)PROFILE_USE_AXIS_Z")
    field(VAL,  "0")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

# Target position array for this axis
record(waveform,"BL45P-MO-STEP-01:Z:Positions") {
    field(DESC, "Axis Z positions")
    field(DTYP, "asynFloat64ArrayOut")
    field(INP,  "@asyn(BRICK1,0)PROFILE_POSITIONS_Z")
    field(NELM, "500000")
    field(FTVL, "DOUBLE")
    field(PREC, "3")
    field(PINI, "YES")
}

record(longout,"BL45P-MO-STEP-01:Z:NoOfPts") {
    field(DESC, "Axis Z Qty Points")
    field(SCAN, "1 second")
    field(OMSL, "closed_loop")
    field(DOL,  "BL45P-MO-STEP-01:Z:Positions.NORD")
}

# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Virtual X
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VX

# This associates an edm screen with the template
# % gui, SAMP01.VX, edm, motor.edl, motor=BL45P-MO-STAGE-01:VX
# % gui, SAMP01.VX, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:VX,filename=motor.edl,box-label=Virtual X

# This associates a BOY screen with the template
# % gui, SAMP01.VX, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:VX,DESC=Virtual X, name=SAMP01.VX
# % gui, SAMP01.VX, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:VX,DESC=Virtual X, name=SAMP01.VX
# % gui, SAMP01.VX, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:VX,DESC=Virtual X, name=SAMP01.VX
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.VX, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:VX

# This makes the component icon reflect the status and severity
# % gui, SAMP01.VX, status, <pv>.MOVN
# % gui, SAMP01.VX, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.VX, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.VX, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.VX, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.VX, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.VX, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.VX, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.VX, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.VX, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.VX, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.VX, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.VX, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.VX, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.VX, command, Stop,  <pv>.STOP
# % gui, SAMP01.VX, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.VX, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.VX, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.VX, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.VX, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.VX, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.VX, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.VX, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.VX, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.VX, enum, Direction,   <pv>.DIR
# % gui, SAMP01.VX, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.VX, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.VX, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.VX, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.VX, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.VX, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.VX, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.VX, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.VX, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.VX, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.VX, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.VX, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.VX, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.VX, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.VX, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.VX, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.VX, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.VX, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.VX, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.VX, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.VX, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.VX, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.VX, demand, PREC,   <pv>.PREC
# % gui, SAMP01.VX, demand, EGU,   <pv>.EGU

# % gui, SAMP01.VX, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.VX, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.VX, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.VX, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.VX, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.VX, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.VX, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.VX, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:VX")
{
	field(DESC,"Virtual X")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,".5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS2,7)")
	field(MRES,".0001")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"100")
	field(DLLM,"-100")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, ".5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, ".5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:VX:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:VX:ADDR") {
    field(PINI, "YES")
    field(VAL, "7")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:VX:PORT") {
    field(PINI, "YES")
    field(VAL, "CS2")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:VX:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:VX:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:VX:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:VX:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:VX:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:VX.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:VX:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VX:ELOSS
record(ai, "BL45P-MO-STAGE-01:VX:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:VX:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:VX:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:VX.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:VX:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:VX:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:VX:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:VX.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:VX.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:VX.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:VX.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:VX:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VX:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:VX:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:VX:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:VX:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:VX:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:VX:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:VX:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:VX:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL45P-MO-STAGE-01:VX:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS2")
}

# add alias for standard CS axis name
alias(BL45P-MO-STAGE-01:VX, BL45P-MO-STEP-01:CS2:M7)# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Virtual Y
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VY

# This associates an edm screen with the template
# % gui, SAMP01.VY, edm, motor.edl, motor=BL45P-MO-STAGE-01:VY
# % gui, SAMP01.VY, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:VY,filename=motor.edl,box-label=Virtual Y

# This associates a BOY screen with the template
# % gui, SAMP01.VY, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:VY,DESC=Virtual Y, name=SAMP01.VY
# % gui, SAMP01.VY, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:VY,DESC=Virtual Y, name=SAMP01.VY
# % gui, SAMP01.VY, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:VY,DESC=Virtual Y, name=SAMP01.VY
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.VY, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:VY

# This makes the component icon reflect the status and severity
# % gui, SAMP01.VY, status, <pv>.MOVN
# % gui, SAMP01.VY, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.VY, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.VY, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.VY, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.VY, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.VY, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.VY, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.VY, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.VY, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.VY, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.VY, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.VY, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.VY, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.VY, command, Stop,  <pv>.STOP
# % gui, SAMP01.VY, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.VY, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.VY, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.VY, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.VY, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.VY, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.VY, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.VY, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.VY, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.VY, enum, Direction,   <pv>.DIR
# % gui, SAMP01.VY, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.VY, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.VY, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.VY, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.VY, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.VY, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.VY, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.VY, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.VY, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.VY, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.VY, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.VY, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.VY, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.VY, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.VY, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.VY, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.VY, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.VY, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.VY, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.VY, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.VY, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.VY, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.VY, demand, PREC,   <pv>.PREC
# % gui, SAMP01.VY, demand, EGU,   <pv>.EGU

# % gui, SAMP01.VY, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.VY, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.VY, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.VY, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.VY, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.VY, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.VY, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.VY, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:VY")
{
	field(DESC,"Virtual Y")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,".5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS2,8)")
	field(MRES,".0001")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"100")
	field(DLLM,"-100")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, ".5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, ".5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:VY:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:VY:ADDR") {
    field(PINI, "YES")
    field(VAL, "8")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:VY:PORT") {
    field(PINI, "YES")
    field(VAL, "CS2")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:VY:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:VY:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:VY:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:VY:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:VY:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:VY.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:VY:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VY:ELOSS
record(ai, "BL45P-MO-STAGE-01:VY:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:VY:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:VY:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:VY.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:VY:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:VY:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:VY:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:VY.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:VY.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:VY.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:VY.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:VY:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VY:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:VY:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:VY:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:VY:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:VY:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:VY:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:VY:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:VY:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL45P-MO-STAGE-01:VY:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS2")
}

# add alias for standard CS axis name
alias(BL45P-MO-STAGE-01:VY, BL45P-MO-STEP-01:CS2:M8)# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails,
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Virtual Z
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VZ

# This associates an edm screen with the template
# % gui, SAMP01.VZ, edm, motor.edl, motor=BL45P-MO-STAGE-01:VZ
# % gui, SAMP01.VZ, edmembed, motor-embed-small.edl, motor=BL45P-MO-STAGE-01:VZ,filename=motor.edl,box-label=Virtual Z

# This associates a BOY screen with the template
# % gui, SAMP01.VZ, boydetail, motorApp_opi/motor_detail.opi, P=BL45P-MO-STAGE-01,M=:VZ,DESC=Virtual Z, name=SAMP01.VZ
# % gui, SAMP01.VZ, boyembed, motorApp_opi/motor_embed_box.opi, P=BL45P-MO-STAGE-01,M=:VZ,DESC=Virtual Z, name=SAMP01.VZ
# % gui, SAMP01.VZ, boyembed, motorApp_opi/motor_embed.opi, P=BL45P-MO-STAGE-01,M=:VZ,DESC=Virtual Z, name=SAMP01.VZ
# FIXME: this should be in pmacUtil or tpmac
# % gui, SAMP01.VZ, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL45P-MO-STAGE-01,M=:VZ

# This makes the component icon reflect the status and severity
# % gui, SAMP01.VZ, status, <pv>.MOVN
# % gui, SAMP01.VZ, sevr

# These define what PVs a motor detail screen should contain
# % gui, SAMP01.VZ, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, SAMP01.VZ, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, SAMP01.VZ, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, SAMP01.VZ, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, SAMP01.VZ, statusbits, At High Limit,  <pv>.HLS, High
# % gui, SAMP01.VZ, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, SAMP01.VZ, demand, User High Limit,  <pv>.HLM
# % gui, SAMP01.VZ, demand, User Low Limit,  <pv>.LLM
# % gui, SAMP01.VZ, demand, Dial High Limit, <pv>.DHLM
# % gui, SAMP01.VZ, demand, Dial Low Limit, <pv>.DLLM

# % gui, SAMP01.VZ, demand, Motor demand,  <pv>.VAL
# % gui, SAMP01.VZ, readback, Motor readback,  <pv>.RBV
# % gui, SAMP01.VZ, command, Stop,  <pv>.STOP
# % gui, SAMP01.VZ, command, Home Forward,  <pv>.HOMF
# % gui, SAMP01.VZ, command, Home Reverse,  <pv>.HOMR
# % gui, SAMP01.VZ, command, Jog Forward, <pv>.JOGF
# % gui, SAMP01.VZ, command, Jog Reverse, <pv>.JOGR
# % gui, SAMP01.VZ, command, Tweak Forward,  <pv>.TWF
# % gui, SAMP01.VZ, command, Tweak Reverse,  <pv>.TWR
# % gui, SAMP01.VZ, demand, Tweak Step,  <pv>.TWV
# % gui, SAMP01.VZ, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, SAMP01.VZ, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, SAMP01.VZ, enum, Direction,   <pv>.DIR
# % gui, SAMP01.VZ, demand, User Offset,  <pv>.OFF
# % gui, SAMP01.VZ, enum, Set/Use,   <pv>.SET
# % gui, SAMP01.VZ, enum, Offset,   <pv>.FOFF
# % gui, SAMP01.VZ, enum, Use Encoder,   <pv>.UEIP

# % gui, SAMP01.VZ, demand, Motor Step Size,  <pv>.MRES
# % gui, SAMP01.VZ, readback, Steps per Rev,   <pv>.SREV
# % gui, SAMP01.VZ, readback, EGUs per Rev,   <pv>.UREV
# % gui, SAMP01.VZ, demand, Encoder Step Size,  <pv>.ERES
# % gui, SAMP01.VZ, readback, Readback Step Size,   <pv>.RRES
# % gui, SAMP01.VZ, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, SAMP01.VZ, demand, Max Velocity,  <pv>.VMAX
# % gui, SAMP01.VZ, demand, Base Velocity,   <pv>.VBAS
# % gui, SAMP01.VZ, demand, Velocity,  <pv>.VELO
# % gui, SAMP01.VZ, demand, Secs to Velocity,  <pv>.ACCL
# % gui, SAMP01.VZ, demand, JVEL,   <pv>.JVEL
# % gui, SAMP01.VZ, demand, Jog Acceleration,   <pv>.JAR
# % gui, SAMP01.VZ, demand, Backlash Distance,   <pv>.BDST
# % gui, SAMP01.VZ, demand, Backlash Velocity,   <pv>.BVEL
# % gui, SAMP01.VZ, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, SAMP01.VZ, demand, Move Fraction,   <pv>.FRAC
# % gui, SAMP01.VZ, demand, Retry Deadband,   <pv>.RDBD
# % gui, SAMP01.VZ, demand, Max Retrys,   <pv>.RTRY

# % gui, SAMP01.VZ, demand, PREC,   <pv>.PREC
# % gui, SAMP01.VZ, demand, EGU,   <pv>.EGU

# % gui, SAMP01.VZ, demand, Output Specification,   <pv>.OUT
# % gui, SAMP01.VZ, readback, Readback Location,   <pv>.RDBL
# % gui, SAMP01.VZ, readback, Desired Output Loc,   <pv>.DOL
# % gui, SAMP01.VZ, readback, Output Mode Select,   <pv>.OMSL
# % gui, SAMP01.VZ, readback, Readback Out Link,   <pv>.RLNK
# % gui, SAMP01.VZ, demand, DMOV Input Link,   <pv>.DINP
# % gui, SAMP01.VZ, demand, RMP Input Link,   <pv>.RINP
# % gui, SAMP01.VZ, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL45P-MO-STAGE-01:VZ")
{
	field(DESC,"Virtual Z")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,".5")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS2,9)")
	field(MRES,".0001")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"100")
	field(DLLM,"-100")
	field(HLM,"")
	field(LLM,"")
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, ".5")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")
	field(RDBL, "")
	field(VMAX, ".5")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL45P-MO-STAGE-01:VZ:SDIS.VAL")
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL45P-MO-STAGE-01:VZ:ADDR") {
    field(PINI, "YES")
    field(VAL, "9")
}

# record that holds the PORT
record(stringout, "BL45P-MO-STAGE-01:VZ:PORT") {
    field(PINI, "YES")
    field(VAL, "CS2")
}

# record that holds the SCALE
record(ao, "BL45P-MO-STAGE-01:VZ:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL45P-MO-STAGE-01:VZ:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL45P-MO-STAGE-01:VZ:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL45P-MO-STAGE-01:VZ:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL45P-MO-STAGE-01:VZ:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL45P-MO-STAGE-01:VZ.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL45P-MO-STAGE-01:VZ:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VZ:ELOSS
record(ai, "BL45P-MO-STAGE-01:VZ:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")
}

# dummy record that looks like an eloss reset
record(calcout, "BL45P-MO-STAGE-01:VZ:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL45P-MO-STAGE-01:VZ:CHECK_SYNC") {
  field(INPA, "BL45P-MO-STAGE-01:VZ.SYNC CP")
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL45P-MO-STAGE-01:VZ:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL45P-MO-STAGE-01:VZ:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL45P-MO-STAGE-01:VZ:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL45P-MO-STAGE-01:VZ.RMP CP")
	field(INPB,"BL45P-MO-STAGE-01:VZ.REP NPP")
	field(INPC,"BL45P-MO-STAGE-01:VZ.MRES NPP")
	field(INPD,"BL45P-MO-STAGE-01:VZ.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL45P-MO-STAGE-01:VZ:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL45P-MO-STAGE-01:VZ:FERRORMAX
record(calc, "BL45P-MO-STAGE-01:VZ:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL45P-MO-STAGE-01:VZ:FERROR.VAL")
	field(INPB,"BL45P-MO-STAGE-01:VZ:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to reset the maximum following error
record(bo, "BL45P-MO-STAGE-01:VZ:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL45P-MO-STAGE-01:VZ:FERRORMAX.VAL")
	field(VAL, "0")
}


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL45P-MO-STAGE-01:VZ:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL45P-MO-STAGE-01:VZ:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL45P-MO-STAGE-01:VZ:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS2")
}

# add alias for standard CS axis name
alias(BL45P-MO-STAGE-01:VZ, BL45P-MO-STEP-01:CS2:M9)